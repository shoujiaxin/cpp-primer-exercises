[TOC]

# 第 6 章 函数

## 6.1 函数基础

- 6.1
  - 形参是定义函数时函数名后括号中的变量名；实参是调用函数时函数名后括号中的表达式
  - 每个形参都是含有一个声明符的声明，只在调用时占用存储单元；实参时常量、变量或表达式，是形参的初始值，其类型必须与对应的形参类型匹配



- 6.2
  - 函数返回值值的类型与函数的返回类型不一致
  - 函数没有返回类型
  - 函数的两个形参同名
  - 函数体没有使用花括号



- 6.3

  ```c++
  unsigned fact(unsigned val) {
    unsigned result = 1;
    while (val > 1) {
      result *= val;
      --val;
    }
    return result;
  }
  ```



- 6.4

  ```c++
  #include <iostream>
  using std::cin;
  using std::cout;
  using std::endl;
  
  void fact() {
    unsigned val, result = 1;
    cout << "Please input a num: ";
    cin >> val;
    for (auto i = val; i > 1; --i) {
      result *= i;
    }
    cout << val << "! is " << result << endl;
  }
  
  int main(int argc, char const *argv[]) {
    fact();
    return 0;
  }
  ```



- 6.5

  ```c++
  unsigned Abs(int val) { return val < 0 ? -val : val; }
  ```



### 6.1.1 局部对象

- 6.6
  - 形参是一种自动对象，函数开始时为形参申请存储空间，因为形参定义在函数体作用域之内，所以一旦函数终止，形参也就被销毁
  - 局部变量的生命周期依赖于定义的方式：在所有函数体之外定义的对象存在于程序的整个执行过程中，此类对象在程序启动时被创建，直到程序结束才会销毁；定义在函数体内对象的作用于此函数执行的过程中
  - 局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响



- 6.7

  ```c++
  #include <iostream>
  using std::cout;
  using std::endl;
  
  size_t conut_calls() {
    static size_t ctr = 0;
    return ctr++;
  }
  
  int main(int argc, char const *argv[]) {
    for (size_t i = 0; i != 10; ++i) {
      cout << conut_calls() << endl;
    }
    return 0;
  }
  ```



### 6.1.2 函数声明

- 6.8

  ```c++
  #ifndef CHAPTER6_H
  #define CHAPTER6_H
  
  unsigned fact(unsigned val);
  unsigned Abs(int val);
  
  #endif
  ```



### 6.1.3 分离式编译

- 6.9

  - `fact.cc`

    ```c++
    #include "Chapter6.h"
    
    unsigned fact(unsigned val) {
      unsigned result = 1;
      while (val > 1) {
        result *= val;
        --val;
      }
      return result;
    }
    ```

  - `factMain.cc`

    ```c++
    #include <iostream>
    #include "Chapter6.h"
    
    int main(int argc, char const *argv[]) {
      unsigned v;
      std::cout << "Please input a number: ";
      std::cin >> v;
      std::cout << v << "! is " << fact(v) << std::endl;
      return 0;
    }
    ```



## 6.2 参数传递

### 6.2.1 传值参数

- 6.10

  ```c++
  void exchange(int *val1, int *val2) {
    int tmp = *val1;
    *val1 = *val2;
    *val2 = tmp;
  }
  ```



### 6.2.2 传引用参数

- 6.11

  ```c++
  void reset(int &val) { val = 0; }
  ```



- 6.12

  ```c++
  void exchange(int &val1, int &val2) {
    int tmp = val1;
    val1 = val2;
    val2 = tmp;
  }
  ```

  引用更易于使用。相比指针，引用不需要多次解引用



- 6.13

  前者的参数使用值传递，后者使用引用传递



- 6.14
  - 函数通过引用形参返回额外信息
  - 函数需要改变形参内容，但是又不能影响传入函数的实参时，形参不能使用引用类型



- 6.15
  - `string` 对象可能会非常长，直接拷贝比较低效，且函数不需要修改 `string` 对象的内容，故使用常量引用；函数目的是查找字符，且不修改形参的值，故使用 `char` 类型；函数通过 `occurs` 返回字符出现的次数，`occurs` 的值是可变的，故使用引用类型
  - 若 `s` 为普通引用，则字符串的内容可能被修改，且无法传入字面值作为实参（第 192 页）
  - 若 `occurs` 为常量引用，则由于 `++occurs;` 语句导致编译报错



### 6.2.3 const 形参和实参

- 6.16

  无法传入字面值作为实参。修改如下

  ```c++
  bool is_empty(const string &s) { return s.empty(); }
  ```



- 6.17

  ```c++
  // 判断 string 对象中是否含有大写字母
  bool hasUpper(const string &str) {
    for (auto c : str) {
      if (isupper(c)) {
        return true;
      }
    }
    return false;
  }
  // 把 string 对象全都改成小写形式
  void lowerStr(string &str) {
    for (auto &c : str) {
      c = tolower(c);
    }
  }
  ```

  不相同。`hasUpper` 使用常量引用，此函数不需要改变传入的实参的值；`lowerStr` 需要改变实参，故使用普通引用



- 6.18

  - 比较两个 `matrix` 类型的对象是否相等

    ```c++
    bool compare(matrix &m1, matrix &m2);
    ```

  - 修改 `vector<int>` 的迭代器所指向的元素的值

    ```c++
    vector<int>::iterator change_val(int val, vector<int>::iterator it);
    ```



- 6.19

  - 不合法，传入的实参数量不对
  - 合法
  - 合法
  - 合法



- 6.20
  - 函数不需要修改传入的实参的值；函数使用字面值常量作为实参初始化 `string` 类型的形参；传入的实参是常量或者常量引用
  - 实参与形参的类型不匹配导致编译错误；无法传入字面值常量作为实参



### 6.2.4 数组形参

- 6.21

  ```c++
  int getLarger(int val, const int *p) { return val > *p ? val : *p; }
  ```

  指向类型为 `const int*`，是指向 `int` 常量的指针



- 6.22

  ```c++
  void exchange(int *p1, int *p2) {
    int *tmp = p1;
    p1 = p2;
    p2 = tmp;
  }
  ```



- 6.23

  ```c++
  #include <iostream>
  using std::begin;
  using std::cout;
  using std::end;
  using std::endl;
  
  void print(int val) { cout << val << endl; }
  
  void print(int *beg, int *end) {
    while (beg != end) {
      cout << *beg++ << endl;
    }
  }
  
  int main(int argc, char const *argv[]) {
    int i = 0, j[2] = {0, 1};
    print(i);
    print(begin(j), end(j));
    return 0;
  }
  ```



- 6.24

  输出数组中的元素。形参的维度表示期望的数组维度，实参不一定，因此可能发生数组越界，修改如下

  ```c++
  void print(int *beg, int *end) {
    while (beg != end) {
      cout << *beg++ << endl;
    }
  }
  ```



### 6.2.5 main：处理命令行选项

- 6.25

  ```c++
  #include <iostream>
  #include <string>
  using std::cout;
  using std::endl;
  using std::string;
  
  int main(int argc, char const *argv[]) {
    string str1 = argv[1], str2 = argv[2];
    cout << str1 + str2 << endl;
    return 0;
  }
  ```



- 6.26

  ```c++
  #include <iostream>
  using std::cout;
  using std::endl;
  
  int main(int argc, char const *argv[]) {
    for (size_t i = 0; i != argc; ++i) {
      cout << argv[i] << endl;
    }
    return 0;
  }
  ```



### 6.2.6 含有可变形参的函数

- 6.27

  ```c++
  int add(initializer_list<int> il) {
    int sum = 0;
    for (auto i : il) {
      sum += i;
    }
    return sum;
  }
  ```



- 6.28

  `elem` 是 `string` 对象的常量引用



- 6.29

  循环控制变量声明成引用类型更加高效



## 6.3 返回类型和 return 语句

### 6.3.2 有返回值的函数

- 6.30

  编译器输出 `error: non-void function 'str_subrange' should return a value [-Wreturn-type]`



- 6.31
  - 返回局部对象的引用是无效的
  - 希望返回的对象被修改时，返回常量的引用无效



- 6.32

  合法，`get` 函数返回 `array` 所指向的整型数组中下标为 `index` 的元素的引用，`main` 函数使用循环调用 `get` 函数，将数组 `ia` 的元素依次赋值为其对应的下标的值



- 6.33

  ```c++
  #include <iostream>
  #include <vector>
  using std::cout;
  using std::vector;
  
  void printVector(vector<int>::const_iterator beg,
                   vector<int>::const_iterator end) {
    cout << *beg;
    if (end - beg > 1) {
      printVector(++beg, end);
    }
  }
  
  int main(int argc, char const* argv[]) {
    vector<int> iv = {0, 1, 2, 3, 4};
    printVector(iv.cbegin(), iv.cend());
    return 0;
  }
  ```



- 6.34

  若 `val` 为正，从结果上来说没有区别，但是过程中多乘了个 1；若 `val` 为负，则函数将不断递归直到自身程序栈空间耗尽为止。



- 6.35

  后置递增运算符返回修改之前的对象，所以递归传入的参数一直未改变，函数将一直递归下去。



### 6.3.3 返回数组指针

- 6.36

  ```c++
  string (&func())[10];
  ```



- 6.37

  ```c++
  // 使用类型别名
  using arrS = string[10];  // typedef string arrS[10];
  arrS& func1();
  // 使用尾置返回类型
  auto func2() -> string (&)[10];
  // 使用 decltype 关键字
  string str[10];
  decltype(str)& func3();
  ```



- 6.38

  ```c++
  decltype(odd)& arrPtr(int i) { return (i % 2) ? odd : even; }
  ```



## 6.4 函数重载

- 6.39
  - 声明返回 `int` 类型的函数 `calc`，其参数为两个 `int` 类型的常量；非法，重载函数时顶层 const 自动忽略，一个拥有顶层 const 的形参悟法与另一个没有顶层 const 的形参区分开，故 `int calc(const int, const int);` 重复声明了 `int calc(int, int);`
  - 声明返回 `double` 类型的函数 `get`，其形参列表为空；非法，`double get()` 与 `int get()` 只有返回类型不同，重载函数不允许两个函数除了返回类型外其他所有的要素都相同
  - 申明返回 `double*` 类型的函数 `reset`，其形参为 `double*` 类型，函数重载了 `int *reset(int *);`



## 6.5 特殊用途语言特性

### 6.5.1 默认参数

- 6.40
  - 正确
  - 错误，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值



- 6.41
  - 非法，第一个形参没有默认值，必须使用实参初始化
  - 合法
  - 合法，但与初衷不符，`'*'` 被强制类型转换为 `int` 类型传入第二个形参



- 6.42

  ```c++
  #include <iostream>
  #include <string>
  using std::cout;
  using std::endl;
  using std::string;
  
  string make_plural(size_t ctr, const string &word, const string &ending = "s") {
    return (ctr > 1) ? word + ending : word;
  }
  
  int main(int argc, char const *argv[]) {
    cout << make_plural(1, "success") << endl;
    cout << make_plural(2, "success", "es") << endl;
    cout << make_plural(1, "failure") << endl;
    cout << make_plural(2, "failure") << endl;
    return 0;
  }
  ```



### 6.5.2 内联函数和 constexpr 函数

- 6.43
  - 放在头文件。内联函数可以在程序中多次定义，但是对于某个给定的内联函数，它的多个定义必须完全一致
  - 放在头文件。声明 `void` 类型的函数 `putValues`



- 6.44

  ```c++
  inline bool isShorter(const string &s1, const string &s2) {
    return s1.size() < s2.size();
  }
  ```



- 6.45

  内联机制用于优化规模较小、流程直接、频繁调用的函数



- 6.46

  不能，constexpr 函数的返回类型及所有形参的类型都必须是字面值类型



### 6.5.3 调试帮助

- 6.47

  ```c++
  void printVector(vector<int>::const_iterator beg,
                   vector<int>::const_iterator end) {
  #ifndef NDEBUG
    std::clog << "Vector size: " << end - beg << endl;
  #endif
    cout << *beg;
    if (end - beg > 1) {
      printVector(++beg, end);
    }
  }
  ```



- 6.48

  读取用户输入的字符串，若不等于 `sought` 则进行循环；不合理，应改为 `assert(s == sought)`



## 6.6 函数匹配

- 6.49
  - 候选函数是指在一组重载函数中，与被调用的函数同名、声明在调用点可见的函数
  - 可行函数是指在候选函数中，形参数量和本次调用提供的实参数量相等、每个实参的类型与对应的形参类型相同或者能转换成形参的类型的函数



- 6.50
  - 可行函数：`void f(int, int);` 和 `void f(double, double = 3.14);`；此调用具有二义性，不合法
  - 可行函数：`void f(int);` 和 `void f(double, double = 3.14);`；前者为最佳匹配
  - 可行函数：`void f(int, int);` 和 `void f(double, double = 3.14);`；前者为最佳匹配
  - 可行函数：`void f(int, int);` 和 `void f(double, double = 3.14);`；后者为最佳匹配



- 6.51

  ```c++
  #include <iostream>
  using std::cout;
  using std::endl;
  
  void f() { cout << "void f();" << endl; }
  
  void f(int val) { cout << "void f(int);" << endl; }
  
  void f(int val1, int val2) { cout << "void f(int, int);" << endl; }
  
  void f(double val1, double val2 = 3.14) {
    cout << "void f(double, double = 3.14)" << endl;
  }
  
  int main(int argc, char const* argv[]) {
    // f(2.56, 42);  // 二义性
    f(42);
    f(42, 0);
    f(2.56, 3.14);
    return 0;
  }
  ```



### 6.6.1 实参类型转换

- 6.52
  - 第 3 级，通过类型提升实现的匹配
  - 第 4 级，通过算数类型转换实现的匹配



- 6.53
  - 重载 `int calc(int&, int&);` 函数，使用常量引用作为形参
  - 重载 `int calc(char*, char*)` 函数，使用指向 `char` 类型常量的指针作为形参
  - 不合法，重复声明了 `int calc(char*, char*);`，重载函数无法区分是否有顶层 const



## 6.7 函数指针

- 6.54

  ```c++
  int func(int, int);
  vector<decltype(func)*> vec;
  ```



- 6.55

  ```c++
  int add(int val1, int val2) { return val1 + val2; }
  int minus(int val1, int val2) { return val1 - val2; }
  int multiply(int val1, int val2) { return val1 * val2; }
  int divide(int val1, int val2) { return val1 / val2; }
  
  vec.push_back(add);
  vec.push_back(minus);
  vec.push_back(multiply);
  vec.push_back(divide);
  ```



- 6.56

  ```c++
  for (auto f : vec) {
    cout << f(1, 2) << endl;
  }
  ```

  输出结果：

  ```
  3
  -1
  2
  0
  ```
