[TOC]

# 第 7 章 类

## 7.1 定义抽象数据类型

### 7.1.1 设计 Sales_data 类

- 7.1

  ```c++
  #include <iostream>
  #include <string>
  
  struct Sales_data {
    std::string isbn;
    unsigned int num = 0;
    double price = 0.0;    // 单价
    double revenue = 0.0;  // 总收入
  };
  
  int main(int argc, char const* argv[]) {
    Sales_data total;
    if (std::cin >> total.isbn >> total.num >> total.price) {
      total.revenue = total.num * total.price;
      Sales_data trans;
      while (std::cin >> trans.isbn >> trans.num >> trans.price) {
        if (total.isbn == trans.isbn) {
          trans.revenue = trans.num * trans.price;
          total.num += trans.num;
          total.revenue += trans.revenue;
        } else {
          std::cout << total.isbn << " " << total.num << " " << total.revenue
                    << " " << total.revenue / total.num << std::endl;
          total = trans;
        }
      }
      std::cout << total.isbn << " " << total.num << " " << total.revenue << " "
                << total.revenue / total.num << std::endl;
    } else {
      std::cerr << "No data?!" << std::endl;
      return -1;
    }
    return 0;
  }
  ```



### 7.1.2 定义改进的 Sales_data 类

- 7.2

  ```c++
  struct Sales_data {
    std::string bookNo;
    unsigned int num = 0;
    double price = 0.0;    // 单价
    double revenue = 0.0;  // 总收入
  
    Sales_data& combine(const Sales_data& rhs) {
      num += rhs.num;
      revenue += rhs.revenue;
      return *this;
    }
  
    std::string isbn() const { return bookNo; }
  };
  ```



- 7.3

  ```c++
  #include <iostream>
  #include <string>
  
  struct Sales_data {
    std::string bookNo;
    unsigned int num = 0;
    double price = 0.0;    // 单价
    double revenue = 0.0;  // 总收入
  
    Sales_data& combine(const Sales_data& rhs) {
      num += rhs.num;
      revenue += rhs.revenue;
      return *this;
    }
  
    std::string isbn() const { return bookNo; }
  };
  
  int main(int argc, char const* argv[]) {
    Sales_data total;
    if (std::cin >> total.bookNo >> total.num >> total.price) {
      total.revenue = total.num * total.price;
      Sales_data trans;
      while (std::cin >> trans.bookNo >> trans.num >> trans.price) {
        if (total.bookNo == trans.bookNo) {
          trans.revenue = trans.num * trans.price;
          total.combine(trans);
        } else {
          std::cout << total.bookNo << " " << total.num << " " << total.revenue
                    << " " << total.revenue / total.num << std::endl;
          total = trans;
        }
      }
      std::cout << total.bookNo << " " << total.num << " " << total.revenue << " "
                << total.revenue / total.num << std::endl;
    } else {
      std::cerr << "No data?!" << std::endl;
      return -1;
    }
    return 0;
  }
  ```



- 7.4

  ```c++
  struct Person {
    string name;
    string adress;
  };
  ```



- 7.5

  ```c++
  struct Person {
    std::string name;
    std::string address;
  
    std::string Name() const { return name; }
    std::string Address() const { return address; }
  };
  ```

  是 const 的，这些函数不修改 this 所指的对象，使用 cosnt 能提高函数的灵活性

### 7.1.3 定义类相关的非成员函数

- 7.6

  ```c++
  Sales_data& add(Sales_data& data1, Sales_data& data2) {
    Sales_data sum = data1;
    return sum.combine(data2);
  }
  
  std::istream& read(std::istream& is, Sales_data& data) {
    is >> data.bookNo >> data.num >> data.price;
    data.revenue = data.num * data.price;
    return is;
  }
  
  std::ostream& print(std::ostream& os, const Sales_data& data) {
    os << data.isbn() << " " << data.num << " " << data.revenue << " "
       << data.avg_price();
    return os;
  }
  ```



- 7.7

  ```c++
  int main(int argc, char const* argv[]) {
    Sales_data total;
    if (read(std::cin, total)) {
      Sales_data trans;
      while (read(std::cin, trans)) {
        if (total.isbn() == trans.isbn())
          total.combine(trans);
        else {
          print(std::cout, total) << std::endl;
          total = trans;
        }
      }
      print(std::cout, total) << std::endl;
    } else {
      std::cerr << "No data?!" << std::endl;
    }
    return 0;
  }
  ```



- 7.8

  因为 `read` 需要修改 `Sales_data` 对象，而 `print` 不需要



- 7.9

  ```c++
  std::istream& read(std::istream& is, Person& p) {
    is >> p.name >> p.address;
    return is;
  }
  
  std::ostream& print(std::ostream& os, const Person& p) {
    os << p.Name() << " " << p.Address();
    return os;
  }
  ```



- 7.10

  从 `cin` 读取数据，依次存入 `data1` 和 `data2`



### 7.1.4 构造函数

- 7.11

  ```c++
  #include <iostream>
  #include <string>
  
  struct Sales_data {
    Sales_data() = default;
    Sales_data(const std::string& str) : bookNo(str) {}
    Sales_data(const std::string& str, unsigned n, double p)
        : bookNo(str), num(n), price(p), revenue(n * p) {}
    Sales_data(std::istream& is);
  
    std::string bookNo;
    unsigned int num = 0;
    double price = 0.0;    // 单价
    double revenue = 0.0;  // 总收入
  
    Sales_data& combine(const Sales_data& rhs) {
      num += rhs.num;
      revenue += rhs.revenue;
      return *this;
    }
  
    std::string isbn() const { return bookNo; }
    double avg_price() const { return num ? revenue / num : 0; }
  };
  
  Sales_data& add(Sales_data& data1, Sales_data& data2) {
    Sales_data sum = data1;
    return sum.combine(data2);
  }
  
  std::istream& read(std::istream& is, Sales_data& data) {
    is >> data.bookNo >> data.num >> data.price;
    data.revenue = data.num * data.price;
    return is;
  }
  
  std::ostream& print(std::ostream& os, const Sales_data& data) {
    os << data.isbn() << " " << data.num << " " << data.revenue << " "
       << data.avg_price();
    return os;
  }
  
  Sales_data::Sales_data(std::istream& is) { read(is, *this); }
  
  int main(int argc, char const* argv[]) {
    Sales_data data1;
    Sales_data data2("0-201-78345-X");
    Sales_data data3("0-201-78345-X", 3, 20);
    Sales_data data4(std::cin);
    return 0;
  }
  ```



- 7.12

  ```c++
  struct Sales_data {
    Sales_data() = default;
    Sales_data(const std::string& str) : bookNo(str) {}
    Sales_data(const std::string& str, unsigned n, double p)
        : bookNo(str), num(n), price(p), revenue(n * p) {}
    Sales_data(std::istream& is) {
      is >> this->bookNo >> this->num >> this->price;
      this->revenue = this->num * this->price;
    }
  
    std::string bookNo;
    unsigned int num = 0;
    double price = 0.0;    // 单价
    double revenue = 0.0;  // 总收入
  
    Sales_data& combine(const Sales_data& rhs) {
      num += rhs.num;
      revenue += rhs.revenue;
      return *this;
    }
  
    std::string isbn() const { return bookNo; }
    double avg_price() const { return revenue / num; }
  };
  ```



- 7.13

  ```c++
  int main(int argc, char const* argv[]) {
    Sales_data total(std::cin);
    Sales_data trans;
    while (read(std::cin, trans)) {
      if (total.isbn() == trans.isbn())
        total.combine(trans);
      else {
        print(std::cout, total) << std::endl;
        total = trans;
      }
    }
    print(std::cout, total) << std::endl;
    return 0;
  }
  ```



- 7.14

  ```c++
  Sales_data::Sales_data() : bookNo(""), num(0), price(0), revenue(0) {}
  ```



- 7.15

  ```c++
  Person() = default;
  Person(const std::string& n, const std::string& a) : name(n), address(a) {}
  ```


## 7.2 访问控制与封装

- 7.16

  一个类可以包含 0 个或多个访问说明符，且某个访问说明符能出现多少次没有严格规定；每个访问说明符指定了接下来的成员的访问级别，其有效范围直到下一个访问说明符或者到达类的结尾处为止。（第 240 页）



- 7.17

  使用 struct 和 class 定义类唯一的区别就是默认的访问权限：前者字第一个访问说明符之前的成员是 public 的；后者则是 private 的。



- 7.18

  封装即隐藏类的实现细节。封装的用处有：强制用户使用接口、隐藏实现细节，控制用户访问权限。

  封装的益处：

  - 确保用户代码不会无意间破坏封装对象的状态
  - 被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码



- 7.19

  ```c++
  class Person {
   public:
    Person() = default;
    Person(const std::string& n, const std::string& a) : name(n), address(a) {}
    std::string Name() const { return name; }
    std::string Address() const { return address; }
  
   private:
    std::string name;
    std::string address;
  };
  ```



### 7.2.1 友元

- 7.20

  其他类或者函数访问类的非公有成员时需要使用友元。

  利：其他类或函数能直接访问类的非公有成员

  弊：牺牲了封装性与可维护性



- 7.21

  ```c++
  class Sales_data {
    friend Sales_data& add(Sales_data& data1, Sales_data& data2);
    friend std::istream& read(std::istream& is, Sales_data& data);
    friend std::ostream& print(std::ostream& os, const Sales_data& data);
  
   public:
    Sales_data() = default;
    Sales_data(const std::string& str) : bookNo(str) {}
    Sales_data(const std::string& str, unsigned n, double p)
        : bookNo(str), num(n), price(p), revenue(n * p) {}
    Sales_data(std::istream& is) {
      is >> this->bookNo >> this->num >> this->price;
      this->revenue = this->num * this->price;
    }
    std::string isbn() const { return bookNo; }
    Sales_data& combine(const Sales_data& rhs) {
      num += rhs.num;
      revenue += rhs.revenue;
      return *this;
    }
  
   private:
    std::string bookNo;
    unsigned int num = 0;
    double price = 0.0;    // 单价
    double revenue = 0.0;  // 总收入
    double avg_price() const { return num ? revenue / num : 0; }
  };
  ```



- 7.22

  ```c++
  class Person {
    friend std::istream& read(std::istream& is, Person& p);
  
   private:
    Person(const std::string& n, const std::string& a) : name(n), address(a) {}
    std::string Name() const { return name; }
    std::string Address() const { return address; }
  
   private:
    std::string name;
    std::string address;
  };
  ```



## 7.3 类的其他特性

### 7.3.1 类成员再探

- 7.23

  ```c++
  class Screen {
   public:
    Screen() = default;
    Screen(size_t c, size_t h, size_t w, const std::string& s)
        : cursor(c), height(h), width(w), contents(s){};
    Screen(size_t h, size_t w, const std::string& s)
        : height(h), width(w), contents(s){};
    char get(size_t r, size_t c) const { return contents[r * width + c]; }
    Screen& move(size_t r, size_t c) {
      cursor = r * width + c;
      return *this;
    }
  
   private:
    size_t cursor = 0;
    size_t height = 0, width = 0;
    std::string contents;
  };
  ```



- 7.24

  ```c++
  Screen() = default;
  Screen(size_t h, size_t w) : height(h), width(w), contents(h * w, ' '){};
  Screen(size_t h, size_t w, char c)
      : height(h), width(w), contents(h * w, c){};
  ```



- 7.25

  能，类包含 size_t 和 string 成员，其拷贝和赋值的合成版能够正常工作。（第 240 页）



- 7.26

  ```c++
  inline double Sales_data::avg_price() const { return num ? revenue / num : 0; }
  ```



### 7.3.2 返回 *this 的成员函数

- 7.27

  ```c++
  class Screen {
   public:
    Screen() = default;
    Screen(size_t h, size_t w) : height(h), width(w), contents(h * w, ' '){};
    Screen(size_t h, size_t w, char c)
        : height(h), width(w), contents(h * w, c){};
    char getChar(size_t r, size_t c) const { return contents[r * width + c]; }
    Screen& moveCursor(size_t r, size_t c) {
      cursor = r * width + c;
      return *this;
    }
    Screen& setChar(char c) {
      contents[cursor] = c;
      return *this;
    }
    Screen& setChar(size_t r, size_t col, char c) {
      contents[r * width + col] = c;
      return *this;
    }
    Screen& display(std::ostream& os) {
      do_display(os);
      return *this;
    }
    const Screen& display(std::ostream& os) const {
      do_display(os);
      return *this;
    }
  
   private:
    size_t cursor = 0;
    size_t height = 0, width = 0;
    std::string contents;
    void do_display(std::ostream& os) const { os << contents; }
  };
  ```

  输出

  ```
  XXXXXXXXXXXXXXXXXXXX#XXXX
  XXXXXXXXXXXXXXXXXXXX#XXXX
  ```



- 7.28

  输出

  ```
  XXXXXXXXXXXXXXXXXXXX#XXXX
  XXXXXXXXXXXXXXXXXXXXXXXXX
  ```



- 7.29

  第一个输出为临时的 `Screen` 对象，第二个输出为 `myScreen`



- 7.30

  优点：

  - 程序意图更明确
  - 成员函数的形参可以与成员变量相同

  缺点：

  - 代码显得更复杂



### 7.3.3 类类型

- 7.31

  ```c++
  struct Y;
  struct X {
    Y *py;
  };
  
  struct Y {
    X x;
  };
  ```



### 7.3.4 类的作用域

- 7.32

  ```c++
  class Screen;
  
  class Window_mgr {
   public:
    using ScreenIndex = std::vector<Screen>::size_type;
    void clear(ScreenIndex);
    
   private:
    std::vector<Screen> screens;
  };
  
  class Screen {
    friend void Window_mgr::clear(ScreenIndex);
    ...
  }
  
  void Window_mgr::clear(ScreenIndex i) {
    Screen& s = screens[i];
    s.contents = std::string(s.height * s.width, ' ');
  }
  ```



## 7.4 类的作用域

- 7.33

  报错未定义标识符 `pos`，应修改为

  ```c++
  Screen::pos Screen::size() const { return height * width; }
  ```



### 7.4.1 名字查找与类的作用域

- 7.34

  报错 `error: unknown type name 'pos'`



- 7.35

  在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则==类不能再之后重新定义该名字==，即重新定义类型名字是一种错误的行为。（第 255 页）

  若编译器不负责检查重新定义类型的名字，则可修改为

  ```c++
  Exercise::Type Exercise::serVal(Type parm) {
    val = parm + initVal();
    return val;
  }
  ```



## 7.5 构造函数再探

### 7.5.1 构造函数初始值列表

- 7.36

  `rem` 在 `base` 之前被初始化，修改如下

  ```c++
  struct X {
    X(int i, int j) : rem(i % j), base(i) {}
    int rem, base;
  };
  ```



- 7.37
  - `first_item` 使用 `Sales_data(std::istream &is);`，数据成员从输入流中读取
  - `next` 使用默认构造函数，`bookNo = ""; units_sold = 0; revenue = 0.0;`
  - `last` 使用 `Sales_data(std::string s = "");`，`bookNo = "9-999-99999-9"; units_sold = 0; revenue = 0.0;`



- 7.38

  ```c++
  Sales_data(std::istream &is = std::cin) { read(is, *this); }
  ```



- 7.39

  不合法，如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。若接受 `string` 的构造函数和接受 `istream&` 的构造函数都使用默认实参，则无法区分使用哪一个默认构造函数。



- 7.40

  ```c++
  class Employee {
   public:
    Employee() = default;
    Employee(int i, std::string n, int ag = 0, std::string p = "",
             std::string ad = "")
        : id(i), name(n), age(ag), phone(p), address(ad) {}
  
   private:
    int id;
    std::string name;
    int age;
    std::string phone;
    std::string address;
  };
  ```



### 7.5.2 委托构造函数

- 7.41

  ```c++
  class Sales_data {
    friend std::istream& read(std::istream& is, Sales_data& data);
  
   public:
    Sales_data(std::string s, unsigned cnt, double p)
        : bookNo(s), num(cnt), price(p), revenue(cnt * price) {
      std::cout << "Sales_data1" << std::endl;
    }
    Sales_data() : Sales_data("", 0, 0) {
      std::cout << "Sales_data2" << std::endl;
    }
    Sales_data(std::string s) : Sales_data(s, 0, 0) {
      std::cout << "Sales_data3" << std::endl;
    }
    Sales_data(std::istream& is) : Sales_data() {
      read(is, *this);
      std::cout << "Sales_data4" << std::endl;
    }
  
   private:
    std::string bookNo;
    unsigned int num = 0;
    double price = 0.0;    // 单价
    double revenue = 0.0;  // 总收入
  };
  ```

  - 定义变量 `Sales_data data1;`，输出

    ```
    Sales_data1
    Sales_data2
    ```

  - 定义变量 `Sales_data data2("abc");`，输出

    ```
    Sales_data1
    Sales_data3
    ```

  - 定义变量 `Sales_data data3(std::cin);`，输出

    ```
    Sales_data1
    Sales_data2
    Sales_data4
    ```



- 7.42

  ```c++
  class Employee {
   public:
    Employee() = default;
    Employee(int i, std::string n, int ag, std::string p, std::string ad)
        : id(i), name(n), age(ag), phone(p), address(ad) {}
    Employee(int i, std::string n) : Employee(i, n, 0, "", "") {}
  
   private:
    int id;
    std::string name;
    int age;
    std::string phone;
    std::string address;
  };
  
  int main(int argc, char const* argv[]) {
    Sales_data data(std::cin);
    return 0;
  }
  ```



### 7.5.3 默认构造函数的作用

- 7.43

  ```c++
  class NoDefault {
   public:
    NoDefault(int i) {}
  };
  
  class C {
   public:
    C() : c_member(0) {}
  
   private:
    NoDefault c_member;
  };
  ```



- 7.44

  不合法，`NoDefault` 类没有默认构造函数



- 7.45

  合法，`C` 类有默认构造函数



- 7.46
  - 不正确，当类没有声明任何构造函数时，编译器会自动生成默认构造函数。
  - 不正确，默认构造函数无须任何实参，但一个所有参数都有默认实参的构造函数也定义了默认构造函数。
  - 不正确，没有默认构造函数则编译器无法初始化类对象。
  - 不正确，只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数。



### 7.5.4 隐式的类类型转换

- 7.47

  使用 `explicit` 的构造函数可以抑制构造函数定义的隐式转换，但是需要显示地使用构造函数才能转换，意图更加明确，但是代码略显繁琐



- 7.48

  使用构造函数直接初始化 `item1` 和 `item2`



- 7.49
  - 把 `s` 隐式地转换成 `Sales_data`
  - 报错，编译器只会自动地执行一步类型转换（第 264 页）
  - `const` 的 `combine` 函数无法修改对象 `i`



- 7.50

  ```c++
  class Person {
   public:
    Person() = default;
    Person(std::string n, unsigned ag, std::string add, std::string p)
        : name(n), age(ag), address(add), phone(p) {}
    explicit Person(std::string s) : name(s) {}
    explicit Person(std::istream& is) { read(is, *this); }
  
   private:
    std::string name;
    unsigned age;
    std::string address;
    std::string phone;
  };
  ```



- 7.51

  `string` 的单参数构造函数是将 `const char*`，即字面值常量，隐式地转换为 `string`；而 `vector` 的单参数构造函数接受的参数是容器的大小，若不是 `explicit` 则可能会引起歧义。



### 7.5.5 聚合类

- 7.52

  成员初始值列表可以用来初始化聚合类的数据成员，而第 64 页的 `Sales_data` 类的数据成员有类内初始值，故其不是聚合类，修改如下

  ```c++
  struct Sales_data {
    std::string bookNo;
    unsigned units_sold;
    double revenue;
  };
  ```



### 7.5.6 字面值常量

- 7.53

  ```c++
  class Debug {
   public:
    constexpr Debug() = default;
    constexpr Debug(bool h, bool i, bool o) : hw(h), io(i), other(0) {}
    constexpr bool any() const { return hw | io | other; }
    void set_hw(bool h) { hw = h; }
    void set_io(bool i) { io = i; }
    void set_other(bool o) { other = o; }
  
   private:
    bool hw = true;
    bool io = true;
    bool other = true;
  };
  ```



- 7.54

  不应该，`constexpr` 函数的唯一可执行语句是返回语句，而 `set_` 开头的成员函数需要修改数据成员。



- 7.55

  不是，数据成员都是字面值类型的聚合类才是字面值常量类。（第 267 页）



## 7.6 类的静态成员

- 7.56

  类的静态成员存在于任何对象之外，与类本身直接相关，而与类的各个对象无关的成员。



- 7.57

  ```c++
  class Account {
   public:
    void calculate() { amount += amount * interestRate; }
    static double rate() { return interestRate; }
    static void rate(double newRate) { interestRate = newRate; }
  
   private:
    std::string owner;
    double amount;
    static double interestRate;
    static double initRate() { return todayRate; }
  };
  
  double Account::interestRate = initRate();
  ```



- 7.58

  不能在类内初始化非 `const` 的 `static` 成员，修改如下

  ```c++
  class Example {
   public:
    static double rate;
    static const int vecSize = 20;
    static std::vector<double> vec;
  };
  
  double Example::rate = 6.5;
  std::vector<double> Example::vec(vecSize);
  ```
