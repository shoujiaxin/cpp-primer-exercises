# 3.1 命名空间和 using 声明

### 练习 3.1

> 使用恰当的 using 声明重做 [1.4.1 节](../第%201%20章%20开始/第%201%20章%20开始.md/#141-while-语句)（第 11 页）和 [2.6.2 节](../第%202%20章%20变量和基本类型/第%202%20章%20变量和基本类型.md/#262-使用-sales_data-类)（第 67 页）的练习。

- [1.9](3.1_1.9.cpp)
- [1.10](3.1_1.10.cpp)
- [1.11](3.1_1.11.cpp)
- [1.20](3.1_1.20.cpp)
- [1.21](3.1_1.21.cpp)
- [1.22](3.1_1.22.cpp)
- [1.23](3.1_1.23.cpp)
- [1.25](3.1_1.25.cpp)

# 3.2 标准库类型 string

## 3.2.2 string 对象上的操作

### [练习 3.2](3.2.cpp)

> 编写一段程序从标准输入中一次读入一行，然后修改该程序使其一次读入一个词。

### 练习 3.3

> 请说明 string 类的输入运算符和 getline 函数分别是如何处理空白字符的。

输入运算符自动忽略开头的空白（空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇到下一个空白为止；`getline()` 从给定的输入流中读入内容，直到遇到换行符为止，换行符也被读入，但不会存入 `string` 对象中。

### [练习 3.4](3.4.cpp)

> 编写一段程序读取两个字符串，比较其是否相等并输出结果。如果不相等，输出比较大的那个字符串。改写上述程序，比较输入的两个字符串是否等长，如果不等长，输出长度较大的那个字符串。

### [练习 3.5](3.5.cpp)

> 编写一段程序从标准输入中读入多个字符串并将它们连接在一起，输出连接成的大字符串。然后修改上述程序，用空格把输入的多个字符串分割开来。

## 3.2.3 处理 string 对象中的字符

### [练习 3.6](3.6.cpp)

> 编写一段程序，使用范围 for 语句将字符串内所有字符用 X 代替。

### [练习 3.7](3.7.cpp)

> 就上一题完成的程序而言，如果将循环控制的变量设置为 char 将发生什么？先估计一下结果，然后实际编程进行验证。

字符串的值不会改变

### [练习 3.8](3.8.cpp)

> 分别用 while 循环和传统的 for 循环重写第一题的程序，你觉得哪种形式更好呢？为什么？

对于循环次数已知的情况，`for` 循环形式更简单，使用方便，而 `while` 则需使用下标进行迭代。

### 练习 3.9

> 下面的程序有何作用？它合法吗？如果不合法？为什么？
> 
> ```cpp
> string s;
> cout << s[0] << endl;
> ```

不合法，`string s` 默认初始化 `s` 为一个空字符串，不包含任何字符。

### [练习 3.10](3.10.cpp)

> 编写一段程序，读入一个包含标点符号的字符串，将标点符号去除后输出字符串剩余的部分。

### 练习 3.11

> 下面的范围 for 语句合法吗？如果合法，c 的类型是什么？
> 
> ```cpp
> const string s = "Keep out!";
> for (auto &c : s) { /* ... */ }
> ```

合法，`c` 是字符常量引用类型（第 62 页）。

# 3.3 标准库类型 vector

## 3.3.1 定义和初始化 vector 对象

### 练习 3.12

> 下列 vector 对象的定义有不正确的吗？如果有，请指出来。对于正确的，描述其执行结果；对于不正确的，说明其错误的原因。
> 
> (a) `vector<vector<int>> ivec;`
> 
> (b) `vector<string> svec = ivec;`
> 
> (c) `vector<string> svec(10, "null");`

- `vetcor<vector<int>> ivec;` 正确，`vector` 对象的元素是类型为 `int` 的 `vector` 对象
- `vector<string> svec = ivec;` 不正确，`svec` 的元素是 `string` 对象，`ivec` 的元素是 `int` 对象
- `vector<string> svec(10, "null");` 正确，`svec` 包含 10 个 `string` 类型的元素，每个都被初始化为 `"null"`

### 练习 3.13

> 下列的 vector 对象各包含多少个元素？这些元素的值分别是多少？
> 
> (a) `vector<int> v1;`
> 
> (b) `vector<int> v2(10);`
> 
> (c) `vector<int> v3(10, 42);`
> 
> (d) `vector<int> v4{10};`
> 
> (e) `vector<int> v5{10, 42};`
> 
> (f) `vector<string> v6{10};`
> 
> (g) `vector<string> v7{10, "hi"};`

- 初识状态为空
- 10 个 `int` 类型元素，每个都被初始化为 0
- 10 个 `int` 类型元素，每个都被初始化为 42
- 1 个 `int` 类型元素，被初始化为 10
- 2 个 `int` 类型元素，分别为 10，42
- 10 个 `string` 类型元素，每个都被初始化为空字符串
- 10 个 `string` 类型元素，每个都被初始化为 `"hi"`

## 3.3.2 向 vector 对象中添加元素

### [练习 3.14](3.14.cpp)

> 编写一段程序，用 cin 读入一组整数并把它们存入一个 vector 对象。

### [练习 3.15](3.15.cpp)

> 改写上题的程序，不过这次读入的是字符串。

## 3.3.3 其他 vector 操作

### [练习 3.16](3.16.cpp)

> 编写一段程序，把[练习 3.13](#练习-313) 中 vector 对象的容量和具体内容输出出来。检验你之前的回答是否正确，如果不对，回头重新学习 3.3.1 节（第 87 页）直到弄明白错在何处为止。

### [练习 3.17](3.17.cpp)

> 从 cin 读入一组词并把它们存入一个 vector 对象，然后设法把所有词都改为大写形式。输出改变后的结果，每个词占一行。

### 练习 3.18

> 下面的程序合法吗？如果不合法，你准备如何修改？
> 
> ```cpp
> vector<int> ivec;
> ivec[0] = 42;
> ```

不合法，修改如下

```cpp
vector<int> ivec;
ivec.push_back(42);
```

### 练习 3.19

> 如果想定义一个含有 10 个元素的 vector 对象，所有元素的值都是 42，请例举三种不同的实现方法，哪种方式更好呢？

- 方法一：`vector<int> ivec(10, 42);`
- 方法二：`vector<int> ivec{42, 42, 42, 42, 42, 42, 42, 42, 42, 42};`
- 方法三：

  ```cpp
    vector<int> ivec(10);
    for (auto &i : ivec) {
      i = 42;
    }
  ```

方法一更好，简洁。

### [练习 3.20](3.20.cpp)

> 读入一组整数并把它们存入一个 vector 对象，将每对相邻整数的和输出出来。改写你的程序，这次要求先输出第 1 个和最后 1 个元素的和，接着输入第 2 个和倒数第 2 个元素的和，以此类推。

# 3.4 迭代器介绍

## 3.4.1 使用迭代器

### [练习 3.21](3.21.cpp)

> 请使用迭代器重做 [3.3.3 节](#333-其他-vector-操作)（第 94 页）的第一个练习。

### 练习 3.22

> 修改之前那个输出 text 第一段的程序，首先把 text 的第一段全部改成大写形式，然后再输出它。

```cpp
for (auto it = text.begin(); it != text.end() && !it->empty(); ++it) {
  for (auto itc = (*it).begin(); itc != (*it).end(); ++itc) {
    *itc = toupper(*itc);
  }
  cout << *it << endl;
}
```

### [练习 3.23](3.23.cpp)

> 编写一段程序，创建一个含有 10 个整数的 vector 对象，然后使用迭代器将所有元素的值都变成原来的两倍。输出 vector 对象的内容，检验程序是否正确。

## 3.4.2 迭代器运算

### [练习 3.24](3.24.cpp)

> 请使用迭代器重做 [3.3.3 节的最后一个练习](#练习-320)。

### [练习 3.25](3.25.cpp)

> 3.3.3 节（第 93 页）划分分数段的程序是使用下标运算符实现的，请利用迭代器改写该程序实现完全相同的功能。

### 练习 3.26

> 在 100 页的二分搜索程序中，为什么用的是 `mid = beg + (end - beg) / 2`，而非 `mid = (beg + end) / 2 ;`？

`end()` 返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用操作（第 96 页）。

# 3.5 数组

## 3.5.1 定义和初始化内置数组

### 练习 3.27

> 假设 txt_size 是一个无参数的函数，它的返回值是 int。请回答下列哪个定义是非法的，为什么？
> 
> `unsigned buf_size = 1024;`
> 
> (a) `int ia[buf_size];`
> 
> (b) `int ia[4 * 7 - 14];`
> 
> (c) `int ia[txt_size()];`
> 
> (d) `char st[11] = "fundamental"`

- 非法，`buf_size` 不是常量表达式
- 合法
- 当 `txt_size()` 为 `constexpr` 时合法，否则非法
- 非法，初始值过多

### 练习 3.28

> 下列数组中元素的值是什么？
> 
> ```cpp
> string sa[10];
> int ia[10];
> int main() {
>   string sa2[10];
>   int ia2[10];
> }
> ```

`sa` 中元素的值为空字符串；`ia` 中元素的值为 0；`sa2` 和 `ia2` 的初始值未定义

### 练习 3.29

> 相比于 vector 来说，数组有哪些缺点，请例举一些。

数组的大小不能改变，不能随意向数组中增加元素，在某些情况下会损失灵活性

## 3.5.2 访问数组元素

### 练习 3.30

> 指出下面代码中的索引错误。
> 
> ```cpp
> constexpr size_t array_size = 10;
> int ia[array_size];
> for (size_t ix = 1; ix <= array_size; ++ix) ia[ix] = ix;
> ```

`ix` 不能等于 `array_size`

### [练习 3.31](3.31.cpp)

> 编写一段程序，定义一个含有 10 个 int 的数组，令每个元素的值就是其下标值。

### [练习 3.32](3.32.cpp)

> 将上一题刚刚创建的数组拷贝给另一数组。利用 vector 重写程序，实现类似的功能。

### 练习 3.33

> 对于 104 页的程序来说，如果不初始化 scores 将会发生什么？

会输出不确定的错误结果

## 3.5.3 指针和数组

### 练习 3.34

> 假定 p1 和 p2 都指向同一个数组中的元素，则下面程序的功能是什么？什么情况下该程序是非法的？
> 
> ```cpp
> p1 += p2 - p1;
> ```

指针 `p1` 指向 `p2` 所指向的元素；当 `p1` 指向数组尾元素的下一个位置（即 `p1` 为尾后指针）时，此程序非法

### [练习 3.35](3.35.cpp)

> 编写一段程序，利用指针将数组中的元素置为 0。

### [练习 3.36](3.36.cpp)

> 编写一段程序，比较两个数组是否相等。再写一段程序，比较两个 vector 对象是否相等。

## 3.5.4 C 风格字符串

### 练习 3.37

> 下面的程序是何含义，程序的输出结果是什么？
> 
> ```cpp
> const char ca[] = {'h', 'e', 'l', 'l', 'o'};
> const char *cp = ca;
> while (*cp) {
>   cout << *cp << endl;
>   ++cp;
> }
> ```

输出 `"hello"` 中的字符，每个字符占一行，输出结果如下

```
h
e
l
l
o
```

### 练习 3.38

> 在本节中我们提到，将两个指针相加不但是非法的，而且也没有什么意义。请问为什么两个指针相加没有意义？

指针是所指对象在内存中的地址，地址相加并无意义且不合法，且可能造成程序错误

### [练习 3.39](3.39.cpp)

> 编写一段程序，比较两个 string 对象。再编写一段程序，比较两个 C 风格字符串的内容。

### [练习 3.40](3.40.cpp)

> 编写一段程序，定义两个字符数组并用字符串字面值初始化它们；接着再定义一个字符数组存放前两个数组连接后的结果。使用 strcpy 和 strcat 把前两个数组的内容拷贝到第三个数组中。

## 3.5.5 与旧代码的接口

### [练习 3.41](3.41.cpp)

> 编写一段程序，用整型数组初始化一个 vector 对象。

### [练习 3.42](3.42.cpp)

> 编写一段程序，将含有整数元素的 vector 对象拷贝给一个整型数组。

# 3.6 多维数组

### 练习 3.43

> 编写 3 个不同版本的程序，令其均能输出 ia 的元素。版本 1 使用范围 for 语句管理迭代过程；版本 2 和版本 3 都使用普通的 for 语句，其中版本 2 要求使用下标运算符，版本 3 要求用指针。此外，在所有 3 个版本的程序中都要直接写出数据类型，而不能使用类型别名、auto 关键字和 decltype 关键字。

- [版本 1](3.43_1.cpp)
- [版本 2](3.43_2.cpp)
- [版本 3](3.43_3.cpp)

### [练习 3.44](3.44.cpp)

> 改写上一个练习中的程序，使用类型别名来代替循环控制变量的类型。

### [练习 3.45](3.45.cpp)

> 再一次改写程序，这次使用 auto 关键字。

---

上一章：[第 2 章 变量和基本类型](../第%202%20章%20变量和基本类型/第%202%20章%20变量和基本类型.md)

下一章：[第 4 章 表达式](../第%204%20章%20表达式/第%204%20章%20表达式.md)
