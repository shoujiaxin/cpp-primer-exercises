# 14.1 基本概念

### 练习 14.1

> 在什么情况下重载的运算符与内置运算符有所区别？在什么情况下重载的运算符又与内置运算符一样？

内置运算符的含义无法改变，而重载运算符的可以。

### [练习 14.2](14.2.hpp)

> 为 Sales_data 编写重载的输入、输出、加法和复合赋值运算符。

### 练习 14.3

> string 和 vector 都定义了重载的 == 以比较各自的对象，假设 svec1 和 svec2 是存放 string 的 vector，确定在下面的表达式中分别使用了哪个版本的 ==？
>
> (a) `"cobble" == "stone"`
>
> (b) `svec1[0] == svec2[0]`
>
> (c) `svec1 == svec2`
>
> (d) `svec1[0] == "stone"`

- 二者都不是
- `string` 的 `==`
- `vector` 的 `==`
- `string` 的 `==`

### 练习 14.4

> 如何确定下列运算符是否应该是类的成员？
>
> (a) `%`
>
> (b) `%=`
>
> (c) `++`
>
> (d) `->`
>
> (e) `<<`
>
> (f) `&&`
>
> (g) `==`
>
> (h) `()`

- 不是类的成员
- 是类的成员
- 是类的成员
- 是类的成员（必须）
- 不是类的成员
- 不是类的成员
- 不是类的成员
- 是类的成员（必须）

### [练习 14.5](14.5.hpp)

> 在 7.5.1 节中的[练习 7.40](../第%207%20章%20类/第%207%20章%20类.md#练习-740)（第 261 页）中，编写了下列类中某一个的框架，请问在这个类中应该定义重载的运算符吗？如果是，请写出来。
>
> (a) Book
>
> (b) Date
>
> (c) Employee
>
> (d) Vehicle
>
> (e) Object
>
> (f) Tree

# 14.2 输入和输出运算符

## 14.2.1 重载输出运算符 <<

### [练习 14.6](14.2.hpp)

> 为你的 Sales_data 类定义输出运算符。

### [练习 14.7](14.7.hpp)

> 你在 [13.5 节的练习](../第%2013%20章%20拷贝控制/第%2013%20章%20拷贝控制.md#练习-1344)（第 470 页）中曾经编写了一个 String 类，为它定义一个输出运算符。

### [练习 14.8](14.5.hpp)

> 你在 7.5.1 节中的[练习 7.40](../第%207%20章%20类/第%207%20章%20类.md#练习-740)（第 261 页）中曾经选择并编写了一个类，为它定义一个输出运算符。

## 14.2.2 重载输入运算符 >>

### [练习 14.9](14.2.hpp)

> 为你的 Sales_data 类定义输入运算符。

### 练习 14.10

> 对于 Sales_data 的输入运算符来说如果给定了下面的输入将发生什么情况？
>
> (a) 0-201-99999-9 10 24.95
>
> (b) 10 24.95 0-210-99999-9

- 输入正确
- 程序试图将 `0-210-99999-9` 转换为 `float` 类型

### 练习 14.11

> 下面的 Sales_data 输入运算符存在错误吗？如果有，请指出来。对于这个输入运算符如果仍然给定上个练习的输入将会发生什么情况？
>
> ```c++
> istream& operator>>(istream& in, Sales_data& s) {
>   double price;
>   in >> s.bookNo >> s.units_sold >> price;
>   s.revence = s.units_sold >> price;
>   return in;
> }
> ```

没有处理输入可能失败的情况。给定上一题的输入其情况与上一题相同。

### [练习 14.12](14.12.hpp)

> 你在 7.5.1 节中的[练习 7.40](../第%207%20章%20类/第%207%20章%20类.md#练习-740)（第 261 页）中曾经选择并编写了一个类，为它定义一个输入运算符并确保该运算符可以处理输入错误。

# 14.3 算术和关系运算符

### [练习 14.13](14.13.hpp)

> 你认为 Sales_data 类还应该支持哪些其他算术运算符（参见表 4.1，第 124 页）？如果有的话，请给出它们的定义。

### 练习 14.14

> 你觉得为什么调用 operator+= 来定义 operator+ 比其他方法更有效？

调用 `operator+=` 来定义 `operator+` 可以省去一个局部变量。

### 练习 14.15

> 你在 7.5.1 节的[练习 7.40](../第%207%20章%20类/第%207%20章%20类.md#练习-740)（第 261 页）中曾经选择并编写了一个类，你认为它应该含有其他算术运算符吗？如果是，请实现它们；如果不是，解释原因。

`Employee` 类不需要算术运算符。

## 14.3.1 相等运算符

### 练习 14.16

> 为你的 StrBlob 类（参见 12.1.1 节，第 405 页）、StrBlobPtr 类（参见 12.1.6 节，第 421 页）、StrVec 类（参见 13.5 节，第 465 页）和 String 类（参见 13.5 节，第 470 页）分别定义相等运算符和不相等运算符。

- [StrBlob 类](14.16_StrBlob.hpp)
- [StrBlobPtr 类](14.16_StrBlob.hpp)
- [StrVec 类](14.16_StrVec.hpp)
- [String 类](14.16_String.hpp)

### [练习 14.17](14.17.hpp)

> 你在 7.5.1 节的[练习 7.40](../第%207%20章%20类/第%207%20章%20类.md#练习-740)（第 261 页）中曾经选择并编写了一个类，你认为它应该含有相等运算符吗？如果是，请实现它；如果不是，解释原因。

## 14.3.2 关系运算符

### 练习 14.18

> 为你的 StrBlob 类、StrBlobPtr 类、StrVec 类和 String 类分别定义关系运算符。

- [StrBlob 类](14.17_StrBlob.hpp)
- [StrBlobPtr 类](14.17_StrBlob.hpp)
- [StrVec 类](14.17_StrVec.hpp)
- [String 类](14.17_String.hpp)

### [练习 14.19](14.19.hpp)

> 你在 7.5.1 节的[练习 7.40](../第%207%20章%20类/第%207%20章%20类.md#练习-740)（第 261 页）中曾经选择并编写了一个类，你认为它应该含有关系运算符吗？如果是，请实现它；如果不是，解释原因。

# 14.4 赋值运算符

### [练习 14.20](14.13.hpp)

> 为你的 Sales_data 类定义加法和复合赋值运算符。

### [练习 14.21](14.21.hpp)

> 编写 Sales_data 类的 + 和 += 运算符，使得 + 执行实际的加法操作而 += 调用 +。相比 14.3 节（第 497 页）和 14.4 节（第 500 页）对这两个运算符的定义，本题的定义有何缺点？试讨论之。

`+=` 运算中需要额外定义一个不必要的局部变量。

### [练习 14.22](14.22.hpp)

> 定义赋值运算符的一个新版本，使得我们能把一个表示 ISBN 的 string 赋给一个 Sales_data 对象。

### [练习 14.23](14.23.hpp)

>   为你的 StrVec 类定义一个 initializer_list 赋值运算符。

### [练习 14.24](14.24.hpp)

> 你在 7.5.1 节的[练习 7.40](../第%207%20章%20类/第%207%20章%20类.md#练习-740)（第 261 页）中曾经选择并编写了一个类，你认为它应该含有拷贝赋值和移动赋值运算符吗？如果是，请实现它们。

### [练习 14.25](14.25.hpp)

> 上题的这个类还需要定义其他赋值运算符吗？如果是，请实现它们；同时说明运算对象应该是什么类型并解释原因。

# 14.5 下标运算符

### 练习 14.26

> 为你的 StrBlob 类、StrBlobPtr 类、StrVec 类和 String 类定义下标运算符。

- [StrBlob 类](14.26_StrBlob.hpp)
- [StrBlobPtr 类](14.26_StrBlob.hpp)
- [StrVec 类](14.26_StrVec.hpp)
- [String 类](14.26_String.hpp)

# 14.6 递增和递减运算符

### [练习 14.27](14.27.hpp)

> 为你的 StrBlobPtr 类添加递增和递减运算符。

### [练习 14.28](14.28.hpp)

> 为你的 StrBlobPtr 类添加加法和减法运算符，使其可以实现指针的算术运算（参见 3.5.3 节，第 106 页）。

### 练习 14.29

> 为什么不定义 const 版本的递增和递减运算符？

因为递增和递减运算符需要修改对象本身，故不能定义为 const 的。

# 14.7 成员访问运算符

### 练习 14.30

> 为你的 StrBlobPtr 类和在 12.1.6 节[练习 12.22](../第%2012%20章%20动态内存/第%2012%20章%20动态内存.md#练习-1222)（第 423 页）中定义的 ConstStrBlobPtr 类分别添加解引用运算符和箭头运算符。注意：因为 ConstStrBlobPtr 的数据成员指向 const vector，所以 ConstStrBlobPtr 中的运算符必须返回常量引用。

- [StrBlobPtr](14.30_StrBlobPtr.hpp)
- [ConstStrBlobPtr](14.30_ConstStrBlobPtr.hpp)

### 练习 14.31

> 我们的 StrBlobPtr 类没有定义拷贝构造函数、赋值运算符及析构函数，为什么？

不定义拷贝构造函数，编译器会定义一个合成拷贝构造函数，将参数的成员逐个拷贝到正在创建的对象中，这符合我们的预期；同理，合成拷贝赋值运算符以及合成析构函数的行为也符合预期；

### [练习 14.32](14.32.hpp)

> 定义一个类令其含有指向 StrBlobPtr 对象的指针，为这个类定义重载的箭头运算符。

# 14.8 函数调用运算符

## 14.8.1 lambda 是函数对象

## 14.8.2 标准库定义的函数对象

## 14.8.3 可调用对象与 function

# 14.9 重载、类型转换与运算符

## 14.9.1 类型转换运算符

## 14.9.2 避免有二义性的类型转换

## 14.9.3 函数匹配与重载运算符
