[TOC]

# 第 4 章 表达式

## 4.1 基础

### 4.1.2 优先级与结合律

- 4.1

  `5+10*20/2 = 105`



- 4.2

  - `*(vec.begin())`
  - `*(vec.begin()) + 1`



### 4.1.3 求值顺序

- 4.3

  可以接受



## 4.2 算术运算符

- 4.4

  `((12 / 3) * 4) + (5 * 15) + ((24 % 4) / 2) = 91`



- 4.5

  - `-30 * 3 + 21 / 5 = -86`
  - `-30 + 3 * 21 / 5 = -18`
  - `30 / 3 * 21 % 5 = 0`
  - `-30 / 3 * 21 % 4 = -2`



- 4.6

  ```c++
  int ival;
  if (ival % 2 == 0) {
    cout << ival << "是偶数" << endl;
  } else {
    cout << ival << "是奇数" << endl;
  }
  ```



- 4.7

  溢出是指计算的结果超出该类型所能表示的范围

  ```c++
  short shortVal1 = 32768;
  short shortVal2 = 30000 * 2;
  short shortVal3 = 32767 + 1;
  ```



## 4.3 逻辑和关系运算符

- 4.8
  - 在逻辑与中，先计算左侧运算对象，若为真，再计算右侧运算对象
  - 在逻辑或中，先计算左侧运算对象，若为假，再计算右侧运算对象
  - 在相等性运算符中，先计算左侧运算对象，在计算右侧运算对象



- 4.9

  先检查指针 `cp` 是否指向一个对象，如果是，则检查 `cp` 指向的字符数组是否为空，若非空，则条件为真，否则条件为假



- 4.10

  ```c++
  int val;
  while (cin >> val && val != 42) {
    /* ... */
  }
  ```



- 4.11

  ```c++
  if (a > b && b > c && c > d) {
    /* ... */
  }
  ```



- 4.12

  先判断 `j` 和 `k` 的大小关系，若 `j < k`，则当 `i != 1` 时表达式为 `true`，否则表达式为 `false`；若 `j >= k`，则当 `i != 0` 时表达式为 `true`，否则表达式为 `false`



## 4.4 赋值运算符

- 4.13
  - `i = 3, d = 3`
  - `i = 3, d = 3.5`



- 4.14
  - 编译无法通过，字面值 `42` 是右值，无法赋值
  - 程序运行，`i` 被赋值为 42，`if` 条件始终为真



- 4.15

  `pi` 的类型为 `int*`，无法转换为 `ival` 的 `int` 类型。修改如下

  ```c++
  double dval; int ival; int *pi;
  dval = ival = 0; pi = 0;
  ```



- 4.16
  - 赋值运算的优先级较低，修改为 `if ((p = getPtr()) != 0)`
  - 混淆了赋值运算符和相等运算符，修改为 `if (i == 1024)`



## 4.5 递增和递减运算符

- 4.17

  前置递增运算符首先将运算对象加 1，然后将改变后的对象作为左值返回；后置递增运算符将运算对象加 1，但是将改变前的运算对象作为右值返回



- 4.18

  无法输出第一个元素，且若 `vector` 中无负值，将试图解引用一个不存在的元素，造成程序错误



- 4.19
  - `ptr` 是非空指针，且 `ptr` 所指对象不为 0 时表达式为真，并将 `ptr` 加 1
  - `ival` 不为 0 时表达式为真，并将 `ival` 加 1
  - 表达式为真，将 `ival` 加 1



## 4.6 成员访问运算符

- 4.20
  - 合法，返回 `iter` 所指元素的引用，`iter` 指向下一个元素
  - 不合法，返回 `iter` 所指元素的引用，但 `string` 对象不能递增
  - 不合法，解引用运算符的优先级低于点运算符，迭代器没有 `empty()` 成员
  - 合法，判断 `iter` 所指的 `string` 对象是否为空
  - 不合法，返回 `iter` 所指元素的引用，但 `string` 对象不能递增
  - 合法，判断 `iter` 所指的 `string` 对象是否为空，`iter` 指向下一个元素



## 4.7 条件运算符

- 4.21

  ```c++
  vector<int> ivec{0, 1, 2, 3, 5};
  for (auto &i : ivec) {
    i = (i % 2 == 0) ? i : i * 2;
  }
  ```



- 4.22

  ```c++
  // 只使用条件运算符
  string finalGrade =
      (grade > 90) ? "high pass"
                    : (grade > 75) ? "pass" : (grade < 60) ? "fail" : "low pass";
  // 使用 if 语句
  if (grade > 90)
    finalGrade = "high pass";
  else if (grade > 75)
    finalGrade = "pass";
  else if (grade < 60)
    finalGrade = "fail";
  else
    finalGrade = "low pass";
  ```

  使用 if 语句的版本更容易理解，条件运算符嵌套过多



- 4.23

  条件运算符的优先级非常低，原条件表达式判断 `s + s[s.size() - 1]` 和 `'s'` 是否相等，而 `string` 对象和字符字面值无法相互比较。修改如下

  ```c++
  string s = "words";
  string pl = s + ((s[s.size() - 1] == 's') ? "" : "s");
  ```



- 4.24

  第一个条件检查成绩是否在 90 分以上，如果是，得到 `"high pass"`，执行后面的条件表达式：字符串不为空，条件成立，得到 `"fail"`；如果否，执行后面的条件表达式：判断成绩是否在 60 分以下，如果是，得到 `"fail"`；否则得到 `"pass"`



## 4.8 位运算符

- 4.25

  输出 `-7296`，`char` 类型的运算对象会提升成 `int` 类型，提升时运算对象原来的位保持不变，往高位添加 0



- 4.26

  在 `int` 类型为 16 位的机器上会溢出，造成错误结果



- 4.27
  - `ul1 & ul2 = 3`
  - `ul1 | ul2 = 7`
  - `ul1 && ul2 =1`
  - `ul1 || ul2 = 1`



## 4.9 sizeof 运算符

- 4.28

  ```c++
  #include <iostream>
  using std::cout;
  using std::endl;
  
  int main(int argc, char const *argv[]) {
    cout << "Byte(s) of bool: " << sizeof(bool) << endl
         << "Byte(s) of char: " << sizeof(char) << endl
         << "Byte(s) of wchar_t: " << sizeof(wchar_t) << endl
         << "Byte(s) of char16_t: " << sizeof(char16_t) << endl
         << "Byte(s) of char32_t: " << sizeof(char32_t) << endl
         << "Byte(s) of short: " << sizeof(short) << endl
         << "Byte(s) of int: " << sizeof(int) << endl
         << "Byte(s) of long: " << sizeof(long) << endl
         << "Byte(s) of long long: " << sizeof(long long) << endl
         << "Byte(s) of float: " << sizeof(float) << endl
         << "Byte(s) of double: " << sizeof(double) << endl
         << "Byte(s) of long double: " << sizeof(long double) << endl;
    return 0;
  }
  ```



- 4.29

  输出

  ```
  10
  2
  ```

  `int*` 类型的对象（指针）占 8 个字节，`int` 类型的对象占 4 个字节



- 4.30
  - `(sizeof x) + y`
  - `sizeof (p->mem[i])`
  - `(sizeof a) < b`
  - `(sizeof f())`



## 4.10 逗号运算符

- 4.31

  后置递增运算符需要将运算对象的原始值存储下来，将运算对象加 1 后再返回原始值，而此程序无需运算对象的原始值，使用后置递增运算符会造成不必要的浪费。使用后置运算符的程序如下

  ```c++
  auto cnt = ivec.size();
  for (decltype(ivec.size()) ix = 0; ix != ivec.size(); ix++, cnt--) {
    ivec[ix] = cnt;
  }
  ```



- 4.32

  指针 `ptr` 指向数组的第一个元素，索引 `ix` 初始值为 0。每次循环迭代 `ptr` 和 `ix`，只要 `ix` 小于数组大小且指针未指向最后一个元素的下一个位置，就执行循环体，然后将 `ix` 加 1，`ptr` 向后移动一个位置 



- 4.33

  判断 `someValue` 的值，如果为真（不为 0），则 `x` 和 `y` 都递增 1；否则 `x` 和 `y` 都递减 1



## 4.11 类型转换

### 4.11.1 算术转换

- 4.34
  - `fval` 转换成 `bool`
  - `ival` 转换成 `float`，然后该 `float` 值转换成 `double`
  - `cval` 提升成 `int`，然后该 `int` 值转换成 `double`



- 4.35
  - `'a'` 提升成 `int`，然后该 `int` 值转换成 `char`
  - `ival` 转换成 `double`，然后 `ui` 转换成 `double`，然后该 `double` 值转换成 `float`
  - `ui` 转换成 `float`，然后该 `float` 值转换成 `double`
  - `ival` 和 `fval` 转换成 `double`，然后该 `double` 值转换成 `char`



### 4.11.3 显式类型转换

- 4.36

  `i *= static_cast<int>(d)`



- 4.37
  - `pv = static_cast<void *>(const_cast<string *>(ps));`
  - `i = static_cast<int>(*pc);`
  - `pv = static_cast<void *>(&d);`
  - `pc = reinterpret_cast<char *>(pv);`



- 4.38

  将 `j/i` 的结果转换为 `double` 类型赋给 `slope`
