# 2.1 基本内置类型

## 2.1.1 算数类型

### 练习 2.1

> 类型 int、long、long long 和 short 的区别是什么？无符号类型和带符号类型的区别是什么？float 和 double 的区别是什么？

- 这四种整型可以表示的整数范围不同，整型 `int` 最小尺寸为 16 位，长整型 `long` 最小尺寸为 32 位，长整型 `long long` 类型最小尺寸为 64 位，短整型 `short` 最小尺寸为 16 位。
- 无符号类型只能表示大于等于 0 的值，带符号类型可以表示正数、负数或 0 。
- 通常情况下，`float` 使用 32 比特（1 个字）表示，有 7 个有效位；`double` 使用 64 比特（2 个字）表示，有 16 个有效位。



### 练习 2.2

> 计算按揭贷款时，对于利率、本金和付款分别应选择何种数据类型？说明你的理由。

利率、本金和付款均使用 `double` 类型，因为金额、利率的存储和计算过程中都可能会出现小数，使用 `double` 可以保留更多的有效位数和较高的精度。



## 2.1.2 类型转换

### 练习 2.3

> 读程序写结果。
>
> ```c++
> unsigned u = 10, u2 = 42;
> std::cout << u2 - u << std::endl;
> std::cout << u - u2 << std::endl;
> int i = 10, i2 = 42;
> std::cout << i2 - i << std::endl;
> std::cout << i - i2 << std::endl;
> std::cout << i - u << std::endl;
> std::cout << u - i << std::endl;
> ```

结果如下：

```shell
32
4294967264
32
-32
0
0
```



### [练习 2.4](2.4.cpp)

> 编写程序检查你的估计是否正确，如果不正确，请仔细研读本节直到弄明白问题所在。



## 2.1.3 字面值常量

### 练习 2.5

> 指出下述字面值的数据类型并说明每一组内几种字面值的区别：
>
> (a) 'a', L'a', "a", L"a"
>
> (b) 10, 10u, 10L, 10uL, 012, 0xC
>
> (c) 3.14, 3.14f, 3.14L
>
> (d) 10, 10u, 10., 10e-2

- `'A'` 为字符字面值；`L'a'` 为宽字符型字面值，类型为 `whcar_t`；`"a"` 为字符串字面值；`L"a"` 为宽字符串字面值。
- `10` 为十进制整型字面值；`10u` 为十进制无符号整型字面值；`10L` 为十进制长整型字面值；`10uL` 为十进制无符号长整型字面值；`012` 为八进制整型字面值；`0xC` 为十六进制整型字面值。
- `3.14` 为浮点型字面值；`3.14f` 为单精度浮点型字面值，类型是 `float`；`3.14L` 为扩展精度浮点型字面值，类型是 `long double`。
- `10` 为十进制整型字面值；`10u` 为十进制无符号整型字面值；`10.` 为浮点型字面值；`10e-2` 为浮点型字面值。



### 练习 2.6

> 下面两组定义是否有区别，如果有，请叙述之：
>
> ```c++
> int month = 9, day = 7;
> int month = 09, day = 07;
> ```

有区别。`int month = 9, day = 7;` 定义整型变量 `month` 和 `day`，并分别使用十进制整型字面值 9 和 7 初始化；`int month = 09, day = 07;` 定义整型变量 `month` 和 `day`，并分别使用八进制整型字面值 09 和 07 初始化。



### 练习 2.7

> 下述字面值表示何种含义？它们各自的数据类型是什么？
>
> (a) "Who goes with F\145rgus?\012"
>
> (b) 3.14e1L
>
> (c) 1024f
>
> (d) 3.14L

- 字符串字面值，类型为 `char`
- 扩展精度浮点型字面值，类型为 `long double`
- 单精度浮点型字面值，类型为 `float`
- 扩展精度浮点型字面值，类型为 `long double`



### [练习 2.8](2.8.cpp)

> 请利用转义序列编写一段程序，要求先输出 2M，然后转到新一行。修改程序使其先输出 2，然后输出制表符，再输出 M，最后转到新一行。



# 2.2 变量

## 2.2.1 变量定义

### 练习 2.9

> 解释下列定义的含义，对于非法的定义，请说明错在何处并将其改正。
>
> (a) `std::cin >> int input_value;`
>
> (b) `int i = { 3.14 };`
>
> (c) `double salary = wage = 9999.99;`
>
> (d) `int i = 3.14;`

- 不能在输入运算符 `>>` 右侧定义变量。定义改正如下

  ```c++
  int input_value;
  std::cin >> input_value;
  ```

- 使用 `{}` 初始化变量时无法将浮点型转换为整型。定义改正如下

  ```c++
  double i = {3.14};
  ```

- 定义变量时不能连续初始化。定义改正如下

  ```c++
  double salary = 9999.99, wage = 9999.99;
  ```

- 定义整型变量 `i` ，在初始化时将浮点型字面值 3.14 转换为整型 3，即 `i` 被初始化为 3。



### 练习 2.10

> 下列变量的初值分别是什么？
>
> ```c++
> std::string global_str;
> int global_int;
> int main() {
>   int local_int;
>   std::string local_str;
> }
> ```

`global_str` 的初始值为一个空字符串；`global_int` 的初始值为 0；`local_int` 和 `local_str` 的初始值未定义。



## 2.2.2 变量声明和定义的关系

### 练习 2.11

> 指出下面的语句是声明还是定义：
>
> (a) `extern int ix = 1024;`
>
> (b) `int iy;`
>
> (c) `extern int iz;`

- 定义
- 声明并定义
- 声明



## 2.2.3 标识符

### 练习 2.12

> 请指出下面的名字中哪些是非法的？
>
> (a) `int double = 3.14;`
>
> (b) `int _;`
>
> (c) `int catch-22;`
>
> (d) `int 1_or_2 = 1;`
>
> (e) `double Double = 3.14;`

- `int double = 3.14;` 非法
- `int _;` 合法
- `int catch-22;` 非法
- `int 1_or_2 = 1;` 合法
- `double Double = 3.14` 合法



## 2.2.4 名字的作用域

### 练习 2.13

> 下面程序中 j 的值是多少？
>
> ```c++
> int i = 42;
> int main() {
>   int i = 100;
>   int j = i;
> }
> ```

`j` 的值为 100



### 练习 2.14

> 下面的程序合法吗？如果合法，它将输出什么？
>
> ```c++
> int i = 100, sum = 0;
> for (int i = 0; i != 10; ++i) sum += i;
> std::cout << i << " " << sum << std::endl;
> ```

程序合法，输出 `100 45`



# 2.3 复合类型

## 2.3.1 引用

### 练习 2.15

> 下面的哪个定义是不合法的？为什么？
>
> (a) `int ival = 1.01;`
>
> (b) `int &rval1 = 1.01;`
>
> (c) `int &rval2 = ival;`
>
> (d) `int &rval3`

- 合法
- 不合法，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起
- 合法
- 不合法，引用必须初始化



### 练习 2.16

> 考察下面的所有赋值然后回答：哪些赋值是不合法的？为什么？哪些赋值是合法的？它们执行了哪些操作？
>
> `int i = 0, &r1 = i; double d = 0, &r2 = d;`
>
> (a) `r2 = 3.14159;`
>
> (b) `r2 = r1;`
>
> (c) `i = r2;`
>
> (d) `r1 =d;`

- 合法，将 2 赋值给 `r2` 绑定的对象
- 不合法，引用和其初始值对象一直绑定在一起，无法重新绑定到另一个对象
- 合法，将 `r2` 绑定的对象赋值给 `i`
- 合法，将 `d` 赋值给 `r1` 绑定的对象



### 练习 2.17

> 执行下面的代码段将输出什么结果？
>
> ```c++
> int i, &ri = i;
> i = 5;
> ri = 10;
> std::cout << i << " " << ri << std::endl;
> ```

输出 `10 10`



## 2.3.2 指针

### [练习 2.18](2.18.cpp)

> 编写代码分别改变指针的值以及指针所指对象的值。



### 练习 2.19

> 说明指针和引用的主要区别。

- 指针本身是一个对象，允许对指针进行赋值和拷贝，在指针的生命周期内，它可以指向不同的对象；而引用并非对象，它是已经存在的对象的别名，引用和其初始值对象一直绑定在一起，无法重新绑定到另一个对象；
- 指针无须在定义时赋初值；而引用必须初始化。



### 练习 2.20

> 请叙述下面这段代码的作用。
>
> ```c++
> int i = 42;
> int *p1 = &i; 
> *p1 = *p1 * *p1;
> ```

- 定义整型变量 `i`，并初始化其值为 42
- 定义指针 `p1` 指向对象 `i`
- 通过指针 `p1` 访问对象，实现平方运算，即 `42*42`



### 练习 2.21

> 请解释下述定义。在这些定义中有非法的吗？如果有，为什么？
>
> `int i = 0;`
>
> (a) `double *dp = &i;`
>
> (b) `int *ip = i;`
>
> (c) `int *p = &i;`

- 非法，指针的类型与它所指对象的类型必须匹配
- 非法，不能直接将 `int` 变量直接赋值给指针，即使 `int` 变量等于 0
- 合法



### 练习 2.22

> 假设 p 是一个 int 型指针，请说明下述代码的含义。
>
> ```c++
> if (p) // ...
> if (*p) // ...
> ```

- 如果指针 `p` 的值不是 0，则
- 如果指针 `p` 所指的对象不是 0，则



### 练习 2.23

> 给定指针 p，你能知道它是否指向了一个合法的对象吗？如果能，叙述判断的思路；如果不能，也请说明原因。

无法判断。指针可能指向一个对象、指向紧邻对象所占空间的下一个地址、或任意对象。



### 练习 2.24

> 在下面这段代码中为什么 p 合法而 lp 非法？
>
> ```c++
> int i = 42;
> void *p = &i;
> long *lp = &i;
> ```

`void*` 指针可以存放任意类型对象的地址，因此 `p` 合法，而指针 `lp` 的类型与其所指对象不匹配，不合法。



## 2.3.3 理解复合类型的声明

### 练习 2.25

> 说明下列变量的类型和值。
>
> (a) `int *ip, i, &r = i;`
>
> (b) `int i, *ip = 0;`
>
> (c) `int *ip, ip2;`

- `ip` 为 `int` 型指针；`i` 为 `int` 型变量；`r` 为对 `i` 的引用
- `i` 为 `int` 型变量；`ip` 为 `int` 型空指针
- `ip` 为 `int` 型指针；`ip2` 为 `int` 型变量



# 2.4 const 限定符

### 练习 2.26

> 下面哪些语句是合法的？如果不合法，请说明为什么？
>
> (a) `const int buf;`
>
> (b) `int cnt = 0;`
>
> (c) `const int sz = cnt;`
>
> (d) `++cnt; ++sz;`

- 不合法，`const` 对象没有初始化
- 合法
- 合法
- 不合法，`const` 对象一旦创建后其值就不能再改变



## 2.4.2 指针和 const

### 练习 2.27

> 下面的哪些初始化是合法的？请说明原因。
>
> (a) `int i = -1, &r = 0;`
>
> (b) `int *const p2 = &i2;`
>
> (c) `const int i = -1, &r = 0;`
>
> (d) `const int *const p3 = &i2;`
>
> (e) `const int *p1 = &i2;`
>
> (f) `const int &const r2;`
>
> (g) `const int i2 = i, &r = i;`

- 不合法，引用类型的初始值必须是一个对象
- 合法， `p2` 是一个指向 `int` 型变量 `i2` 的 `const` 指针
- 合法，`r` 是一个常量引用
- 合法，`p3` 是一个指向常量对象的常量指针
- 合法，`p1` 是一个指向常量对象的指针
- 不合法
- 合法，`i2` 是一个常量对象，`r` 是对常量的引用



### 练习 2.28

> 说明下面的这些定义是什么意思，挑出其中不合法的。
>
> (a) `int i, *const cp;`
>
> (b) `int *p1, *const p2;`
>
> (c) `const int ic, &r = ic;`
>
> (d) `const int *const p3;`
>
> (e) `const int *p;`

- 不合法，`const` 指针必须初始化
- 不合法，`const` 指针必须初始化
- 不合法，`const` 对象必须初始化
- 不合法，`const` 指针必须初始化
- 定义指向整型常量的指针 `p`



### 练习 2.29

> 假设已有上一个练习中定义的那些变量，则下面的哪些语句是合法的？请说明原因。
>
> (a) `i = ic;`
>
> (b) `p1 = p3;`
>
> (c) `p1 = &ic;`
>
> (d) `p3 = &ic;`
>
> (e) `p2 = p1;`
>
> (f) `ic = *p3;`

- 合法
- 合法
- 合法
- 不合法，`const` 指针的值一旦初始化完成，就不能改变
- 不合法，同上
- 不合法，`const` 对象一旦创建后其值就不能再改变



## 2.4.3 顶层 const

### 练习 2.30

> 对于下面的这些语句，请说明对象被声明成了顶层 const 还是底层 const？
>
> ```c++
> const int v2 = 0;
> int v1 = v2;
> int *p1 = &v1, &r1 = v1;
> const int *p2 = &v2, *const p3 = &i, &r2 = v2;
> ```

`v2` 是顶层 `const`；`p2` 是底层 `const`；靠近 `p3` 的是顶层 `const`，较远的是底层 `const`；`r2` 是底层 `const`



### 练习 2.31

> 假设已有上一个练习中所做的那些声明，则下面的哪些语句是合法的？请说明顶层 const 和底层 const 在每个例子中有何体现。
>
> ```c++
> r1 = v2;
> p1 = p2;
> p2 = p1;
> p1 = p3;
> p2 = p3;
> ```

- `r1 = v2;` 合法，拷贝 `v2` 是可以忽略其顶层 `const`
- `P1 = p2;` 不合法，`p2` 是底层 `const`，而 `p1` 没有
- `P2 = p1;` 合法，`int*` 能转换成 `const int*`
- `P1 = p3;` 不合法，`p3` 包含底层 `const`，而 `p1` 没有
- `P2 = p3;` 合法，`p2` 和 `p3` 都是底层 `const`，拷贝 `p3` 时可以忽略其顶层 `const`



## 2.4.4 constexpr 和常量表达式

### 练习 2.32

> 下面的代码是否合法？如果非法，请设法将其修改正确。
>
> ```c++
> int null = 0, *p = null;
> ```

不合法，修改为 `int null = 0, *p = &null;`



# 2.5 处理类型

## 2.5.2 auto 类型说明符

### 练习 2.33

> 利用本节定义的变量，判断下列语句的运行结果。
>
> ```c++
> a = 42;
> b = 42;
> c = 42;
> d = 42;
> e = 42;
> g = 42;
> ```

- 整型变量 `a` 被赋值为 42
- 整型变量 `b` 被赋值为 42
- 整型变量 `c` 被赋值为 42
- 整型指针 `d` 无法赋值，`int` 类型无法转换为 `int*` 类型
- 指向整数常量的指针 `e` 无法赋值，`int` 类型无法转换为 `const int*` 类型
- 整型常量 `g` 无法赋值，`const` 对象一旦创建后其值就不能再改变



### [练习 2.34](2.34.cpp)

> 基于上一个练习中的变量和语句编写一段程序，输出赋值前后变量的内容，你刚才的推断正确吗？如果不对，请反复研读本节的示例直到你明白错在何处为止。



### [练习 2.35](2.35.cpp)

> 判断下列定义推断出的类型是什么，然后编写程序进行验证。
>
> ```c++
> const int i = 42;
> auto j = i;
> const auto &k = i;
> auto *p = &i;
> const auto j2 = i, &k2 = i;
> ```

`j` 为 `int` 类型；`k` 为的 `i` 常量引用；`p` 为 `int*` 类型；`j2` 为整形常量；`k2` 为的 `i` 常量引用



## 2.5.3 decltype 类型指示符

### 练习 2.36

> 关于下面的代码，请指出每一个变量的类型以及程序结束时它们各自的值。
>
> ```c++
> int a = 3, b = 4;
> decltype(a) c = a;
> decltype((b)) d = a;
> ++c;
> ++d;
> ```

`a` 整型；`b` 整型；`c` 整型；`d` `int&`

`a = 4, b = 4, c = 4, d = 4`



### 练习 2.37

> 赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，如果 i 是 int，则表达式 i = x 的类型是 int&。根据这一特点，请指出下面的代码中每一个变量的类型和值。
>
> ```c++
> int a = 3, b = 4;
> decltype(a) c = a;
> decltype(a = b) d = a;
> ```

`a` 整型；`b` 整型；`c` 整型；`d` `int&`

`a = 3, b = 4, c = 3, d = 3`



### 练习 2.38

> 说明由 decltype 指定类型和由 auto 指定类型有何区别。请举一个例子，decltype 指定的类型与 auto 指定的类型一样；再举一个例子，decltype 指定的类型与 auto 指定的类型不一样。

`auto` 让编译器通过初试值推断变量的类型，并用初始值初始化变量；`decltype` 返回操作数的数据类型，可以不初始化变量。在处理引用时，前者一般忽略顶层 `const`，后者则返回包括顶层 `const` 和引用在内的变量类型。

```c++
int ci = 0, &cj = ci;
// 相同
decltype(cj + 0) a;
auto b = ci;
// 不同
decltype(cj) c = ci;
auto d = ci;
```



# 2.6 自定义数据结构

## 2.6.1 定义 Sales_data 类型

### 练习 2.39

> 编译下面的程序观察其运行结果，注意，如果忘记写类定义体后面的分号会发生什么情况？记录下相关的信息，以后可能会有用。
>
> ```c++
> struct Foo { /* 此处为空  */ }  // 注意：没有分号
> int main()
> {
>   return 0;
> }
> ```

运行结果：`error: expected ';' after struct`



### 练习 2.40

> 根据自己的理解写出 Sales_data 类，最好与书中的例子有所区别。

```c++
struct Sales_data {
  std::string bookNo;
  std::string bookName;
  unsigned int units_sold = 0;
  double price = 0.0;    // 单价
  double revenue = 0.0;  // 总收入
};
```



## 2.6.2 使用 Sales_data 类

### 练习 2.41

> 使用你自己的 Sale_data 类重写 [1.5.1 节](../第%201%20章%20开始/第%201%20章%20开始.md/#151-sales_item-类)（第 20 页）、[1.5.2 节](../第%201%20章%20开始/第%201%20章%20开始.md/#152-初识成员函数)（第 21 页）和 [1.6 节](../第%201%20章%20开始/第%201%20章%20开始.md/#16-书店程序)（第 22 页）的练习。眼下先把 Sales_data 类的定义和 main 函数放在一个文件里。

- [1.20](1.20.cpp)
- [1.21](1.21.cpp)
- [1.22](1.22.cpp)
- [1.23](1.23.cpp)
- [1.25](1.25.cpp)



## 2.6.3 编写自己的头文件

### 练习 2.42

> 根据你自己的理解重写一个 Sales_data.h 头文件，并以此为基础重做 [2.6.2 节](#262-使用-sales_data-类)（第 67 页）的练习。

- [Sales_data.h 头文件](Sales_data.h)
- [1.20](1.20_2.cpp)
- [1.21](1.21_2.cpp)
- [1.22](1.22_2.cpp)
- [1.23](1.23_2.cpp)
- [1.25](1.25_2.cpp)
