[TOC]

# 第 5 章 语句

## 5.1 简单语句

- 5.1

  空语句是最简单的语句，它只含有一个单独的分号，不执行任何逻辑上的功能。当程序的某个地方，语法上需要一条语句但是逻辑上不需要时，使用空语句。



- 5.2

  块（复合语句）是指用花括号括起来的（可能为空的）语句和声明的序列。当程序的某个地方，语法书需要一条语句，但是逻辑上需要多条语句时，使用块。



- 5.3

  ```c++
  while (sum += val, val < 10) {
    ++val;
  }
  ```

  循环体与条件语句写在一起，可读性降低了



## 5.2 语句作用域

- 5.4

  - 使用迭代器遍历 `string` 类型的对象 `s`

    ```c++
    auto iter = s.begin();
    while (iter != s.end()) { /* ... */ }
    ```

  - 将 `find(word)` 的返回值赋给 `bool` 类型的对象 `status`，在 `while` 和 `if` 语句中分别判断 `status` 的真假

    ```c++
    bool status = find(word);
    while (status) { /* ... */ }
    if {!status} { /* ... */ }
    ```



## 5.3 条件语句

### 5.3.1 if 语句

- 5.5

  ```c++
  #include <iostream>
  #include <vector>
  using std::cout;
  using std::endl;
  using std::string;
  using std::vector;
  
  int main(int argc, char const *argv[]) {
    int grade;
    const vector<string> scores = {"F", "D", "C", "B", "A", "A++"};
    string letterGrade;
    if (grade < 60) {
      letterGrade = scores[0];
    } else {
      letterGrade = scores[(grade - 50) / 10];
      if (grade != 100) {
        if (grade % 10 > 7) {
          letterGrade += "+";
        } else if (grade % 10 < 3) {
          letterGrade += "-";
        }
      }
    }
    cout << letterGrade << endl;
    return 0;
  }
  ```



- 5.6

  ```c++
  #include <iostream>
  #include <vector>
  using std::cout;
  using std::endl;
  using std::string;
  using std::vector;
  
  int main(int argc, char const *argv[]) {
    int grade;
    const vector<string> scores = {"F", "D", "C", "B", "A", "A++"};
    string letterGrade =
        (grade < 60)
            ? scores[0]
            : scores[(grade - 50) / 10] +
                  ((grade == 100)
                       ? ""
                       : (grade % 10 > 7) ? "+" : (grade % 10 < 3) ? "-" : "");
  
    cout << letterGrade << endl;
    return 0;
  }
  ```



- 5.7

  - 第二行修改为 `ival1 = ival2;`

  - 修改为

    ```c++
    if (ival < minval) {
      minval = ival;
      occurs = 1;
    }
    ```

  - 修改为

    ```c++
    if (int ival = get_value()) {
      cout << "ival = " << ival << endl;
      if (!ival) {
        cout << "ival = 0\n";
      }
    }
    ```

  - 判断条件修改为 `ival == 0`



- 5.8

  悬垂 else 是指在 if else 语句中，else 分支和 if 分支的匹配问题。C++ 规定 else 与离它最近的尚未匹配 if 匹配。



### 5.3.2 switch 语句

- 5.9

  ```c++
  unsigned aCnt = 0, eCnt = 0, iCnt = 0, oCnt = 0, uCnt = 0;
  char ch;
  while (cin >> ch) {
    if (ch == 'a') {
      ++aCnt;
    } else if (ch == 'e') {
      ++eCnt;
    } else if (ch == 'i') {
      ++iCnt;
    } else if (cn == 'o') {
      ++oCnt;
    } else if (cn == 'u') {
      ++uCnt;
    }
  }
  ```



- 5.10

  ```c++
  unsigned aCnt = 0, eCnt = 0, iCnt = 0, oCnt = 0, uCnt = 0;
  char ch;
  while (cin >> ch) {
    switch (ch) {
      case 'a':
      case 'A':
        ++aCnt;
        break;
      case 'e':
      case 'E':
        ++eCnt;
        break;
      case 'i':
      case 'I':
        ++iCnt;
        break;
      case 'o':
      case 'O':
        ++oCnt;
        break;
      case 'u':
      case 'U':
        ++uCnt;
        break;
    }
  }
  ```



- 5.11

  ```c++
  unsigned aCnt = 0, eCnt = 0, iCnt = 0, oCnt = 0, uCnt = 0, spaceCnt = 0,
            tabCnt = 0, returnCnt = 0;
  char ch;
  switch (ch) {
    case 'a':
    case 'A':
      ++aCnt;
      break;
    case 'e':
    case 'E':
      ++eCnt;
      break;
    case 'i':
    case 'I':
      ++iCnt;
      break;
    case 'o':
    case 'O':
      ++oCnt;
      break;
    case 'u':
    case 'U':
      ++uCnt;
      break;
    case ' ':
      ++spaceCnt;
      break;
    case '\t':
      ++tabCnt;
      break;
    case '\n':
      ++returnCnt;
      break;
  }
  ```



- 5.12

  ```c++
  unsigned ffCnt = 0, flCnt = 0, fiCnt = 0;
  char ch;
  while (cin >> ch) {
    switch (ch) {
      case 'f':
        cin >> ch;
        switch (ch) {
          case 'f':
            ++ffCnt;
            break;
          case 'l':
            ++flCnt;
            break;
          case 'i':
            ++fiCnt;
            break;
        }
    }
  }
  ```



- 5.13

  - 没有 break

    ```c++
    unsigned aCnt = 0, eCnt = 0, iouCnt = 0;
    char ch = next_text();
    switch (ch) {
      case 'a':
        ++aCnt;
        break;
      case 'e':
        ++eCnt;
        break;
      default:
        ++iouCnt;
        break;
    }
    ```

  - 变量 `ix` 在 `case 1` 标签的作用域内初始化，但是在 `default` 标签的作用域内被赋值

    ```c++
    unsigned index = some_value();
    switch (index) {
      case 1:
        ivec[get_value()] = index;
        break;
      default:
        ivec[ivec.size() - 1] = index;
    }
    ```

  - `case` 标签必须是整型常量表达式（第 161 页）

    ```c++
    unsigned evenCnt = 0, oddCnt = 0;
    int digit = ged_num() % 10;
    switch (digit) {
      case 1:
      case 3:
      case 5:
      case 7:
      case 9:
        ++oddCnt;
        break;
      case 2:
      case 4:
      case 6:
      case 8:
      case 10:
        ++evenCnt;
        break;
    }
    ```

  - `case` 标签必须是整型常量表达式

    ```c++
    constexpr unsigned ival = 512, jval = 1024, kval = 4096;
    unsigned bufsize;
    unsigned swt = get_bufCnt();
    switch (swt) {
      case ival:
        bufsize = ival * sizeof(int);
        break;
      case jval:
        bufsize = jval * sizeof(int);
        break;
      case kval:
        bufsize = kval * sizeof(int);
        break;
    }
    ```



## 5.4 迭代语句

### 5.4.1 while 语句

- 5.14

  ```c++
  #include <iostream>
  #include <string>
  using std::cin;
  using std::cout;
  using std::endl;
  using std::string;
  
  int main(int argc, char const *argv[]) {
    string lastStr, currStr;
    unsigned cnt = 1, wordCnt = 0;
    while (cin >> currStr) {
      if (currStr == lastStr) {
        ++cnt;
      } else {
        if (cnt > 1) {
          cout << lastStr << " 连续出现 " << cnt << " 次\n";
          ++wordCnt;
        }
        cnt = 1;
      }
      lastStr = currStr;
    }
    if (cnt > 1) {
      cout << lastStr << " 连续出现 " << cnt << " 次\n";
    } else if (wordCnt == 0) {
      cout << "没有连续出现的单词\n";
    }
    return 0;
  }
  ```



### 5.4.2 传统的 for 语句

- 5.15

  - `ix` 从 0 递增到 `sz`。if 语句无用，修改如下

    ```c++
    for (int ix = 0; ix < sz, ++ix) { /* ... */ }
    ```

  - `ix` 从 0 递增到 `sz`。缺少 init-statement，修改如下

    ```c++
    for (int ix = 0; ix < sz; ++ix) { /* ... */ }
    ```

  - `ix` 从 0 递增到 `sz`。`sz` 也在递增，死循环，修改如下

    ```c++
    for (int ix = 0; ix < sz; ++ix) { /* ... */ }
    ```



- 5.16

  更倾向于 for，使用更方便，也更灵活



- 5.17

  ```c++
  #include <iostream>
  #include <vector>
  using std::cout;
  using std::endl;
  using std::vector;
  
  int main(int argc, char const *argv[]) {
    vector<int> ivec1{0, 1, 1, 2}, ivec2{0, 1, 1, 2, 3, 5, 8};
    auto sz1 = ivec1.size(), sz2 = ivec2.size();
    if (sz1 != sz2) {
      for (decltype(sz1) ix = 0, sz = (sz1 < sz2) ? sz1 : sz2;
           ix < sz && ivec1[ix] == ivec2[ix]; ++ix) {
        if (ix == sz - 1) {
          cout << "true" << endl;
        }
      }
    }
    return 0;
  }
  ```




### 5.4.4 do while 语句

- 5.18

  - 计算两个数的和。语句块未加括号，修改如下

    ```c++
    do {
      int v1, v2;
      cout << "Please enter two numbers to sum: ";
      if (cin >> v1 >> v2) cout << "Sum is: " << v1 + v2 << endl;
    } while (cin);
    ```

  - 循环直到 `ival` 为 0。condition 使用的变量必须定义在循环体之外，修改如下

    ```c++
    init ival;
    do {
      // ...
    } while (ival = get_response())
    ```

  - 同上



- 5.19

  ```c++
  #include <iostream>
  #include <string>
  using std::cin;
  using std::cout;
  using std::endl;
  using std::string;
  
  int main(int argc, char const *argv[]) {
    do {
      string str1, str2;
      cout << "Please enter two strings to compare: ";
      if (cin >> str1 >> str2) {
        if (str1.size() == str2.size()) {
          cout << "These two strings are as the same length" << endl;
        } else {
          cout << "The shorter one is: "
               << ((str1.size() < str2.size()) ? str1 : str2) << endl;
        }
      }
    } while (cin);
    return 0;
  }
  ```



## 5.5 跳转语句

### 5.5.1 break 语句

- 5.20

  ```c++
  #include <iostream>
  #include <string>
  using std::cin;
  using std::cout;
  using std::endl;
  using std::string;
  
  int main(int argc, char const *argv[]) {
    string lastWord, currWord;
    unsigned cnt = 0;
    while (cin >> currWord) {
      if (currWord == lastWord) {
        cout << "\"" << currWord << "\" occurs again!" << endl;
        ++cnt;
        break;
      }
      lastWord = currWord;
    }
    if (cnt == 0) {
      cout << "There is no duplicated word!" << endl;
    }
    return 0;
  }
  ```



### 5.5.2 continue 语句

- 5.21

  ```c++
  #include <iostream>
  #include <string>
  using std::cin;
  using std::cout;
  using std::endl;
  using std::string;
  
  int main(int argc, char const *argv[]) {
    string lastWord, currWord;
    unsigned cnt = 0;
    while (cin >> currWord) {
      if (!isupper(currWord[0])) {
        continue;
      }
      if (currWord == lastWord) {
        cout << "\"" << currWord << "\" occurs again!" << endl;
        ++cnt;
        break;
      }
      lastWord = currWord;
    }
    if (cnt == 0) {
      cout << "There is no duplicated word!" << endl;
    }
    return 0;
  }
  ```



### 5.5.3 goto 语句

- 5.22

  ```c++
  int sz;
  do {
    sz = get_size();
  } while (sz <= 0);
  ```



## 5.6 try 语句块和异常处理

### 5.6.3 标准异常

- 5.23

  ```c++
  #include <iostream>
  using std::cin;
  using std::cout;
  using std::endl;
  using std::runtime_error;
  
  int main(int argc, char const *argv[]) {
    int ival1, ival2;
    while (cin >> ival1 >> ival2) {
      try {
        if (ival2 == 0) {
          throw runtime_error("The dividend can't be zero!");
        }
        cout << ival1 << " / " << ival2 << " = "
             << static_cast<double>(ival1) / ival2 << endl;
      } catch (runtime_error err) {
        cout << err.what() << endl;
      }
    }
    return 0;
  }
  ```



- 5.24

  代码同上。若程序无 catch 语句编译报错 `error: expected catch`；若 catch 语句后的块为空，则无任何现象



- 5.25

  ```c++
  #include <iostream>
  using std::cin;
  using std::cout;
  using std::endl;
  using std::runtime_error;
  
  int main(int argc, char const *argv[]) {
    int ival1, ival2;
    while (cin >> ival1 >> ival2) {
      try {
        if (ival2 == 0) {
          throw runtime_error("The dividend can't be zero!");
        }
        cout << ival1 << " / " << ival2 << " = "
             << static_cast<double>(ival1) / ival2 << endl;
      } catch (runtime_error err) {
        cout << err.what() << endl << "Try Again? Enter yes(y) or no(n)" << endl;
        char c;
        cin >> c;
        if (!c || c == 'n') {
          break;
        }
      }
    }
    return 0;
  }
  ```
