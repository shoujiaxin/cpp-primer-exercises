[TOC]

# 第 2 章 变量和基本类型

## 2.1 基本内置类型

### 2.1.1 算数类型

- 2.1

  - 这四种整型可以表示的整数范围不同，整型 `int` 最小尺寸为 16 位，长整型 `long` 最小尺寸为 32 位，长整型 `long long` 类型最小尺寸为 64 位，短整型 `short` 最小尺寸为 16 位。
  - 无符号类型只能表示大于等于 0 的值，带符号类型可以表示正数、负数或 0 。
  - 通常情况下，`float` 使用 32 比特（1 个字）表示，有 7 个有效位；`double` 使用 64 比特（2 个字）表示，有 16 个有效位。



- 2.2

  利率、本金和付款均使用 `double` 类型，因为金额、利率的存储和计算过程中都可能会出现小数，使用 `double` 可以保留更多的有效位数和较高的精度。



### 2.1.2 类型转换

- 2.3

  ```shell
  32
  4294967264
  32
  -32
  0
  0
  ```



### 2.1.3 字面值常量

- 2.5

  - `'A'` 为字符字面值；`L'a'` 为宽字符型字面值，类型为 `whcar_t`；`"a"` 为字符串字面值；`L"a"` 为宽字符串字面值。
  - `10` 为十进制整型字面值；`10u` 为十进制无符号整型字面值；`10L` 为十进制长整型字面值；`10uL` 为十进制无符号长整型字面值；`012` 为八进制整型字面值；`0xC` 为十六进制整型字面值。
  - `3.14` 为浮点型字面值；`3.14f` 为单精度浮点型字面值，类型是 `float`；`3.14L` 为扩展精度浮点型字面值，类型是 `long double`。
  - `10` 为十进制整型字面值；`10u` 为十进制无符号整型字面值；`10.` 为浮点型字面值；`10e-2` 为浮点型字面值。



- 2.6

  有区别。`int month = 9, day = 7;` 定义整型变量 `month` 和 `day`，并分别使用十进制整型字面值 9 和 7 初始化；`int month = 09, day = 07;` 定义整型变量 `month` 和 `day`，并分别使用八进制整型字面值 09 和 07 初始化。



- 2.7

  - 字符串字面值，类型为 `char`
  - 扩展精度浮点型字面值，类型为 `long double`
  - 单精度浮点型字面值，类型为 `float`
  - 扩展精度浮点型字面值，类型为 `long double`



- 2.8

  ```c++
  #include <iostream>
  
  int main(int argc, char const *argv[]) {
    std::cout << "2\115\n";
    std::cout << "2\t\115" << std::endl;
    return 0;
  }
  ```



## 2.2 变量

### 2.2.1 变量定义

- 2.9

  - 不能在输入运算符 `>>` 右侧定义变量。定义改正如下

    ```c++
    int input_value;
    std::cin >> input_value;
    ```

  - 使用 `{}` 初始化变量时无法将浮点型转换为整型。定义改正如下

    ```c++
    double i = {3.14};
    ```

  - 定义变量时不能连续初始化。定义改正如下

    ```c++
    double salary = 9999.99, wage = 9999.99;
    ```

  - 定义整型变量 `i` ，在初始化时将浮点型字面值 3.14 转换为整型 3，即 `i` 被初始化为 3。



- 2.10

  `global_str` 的初始值为一个空字符串；`global_int` 的初始值为 0；`local_int` 和 `local_str` 的初始值未定义。



### 2.2.2 变量声明和定义的关系

- 2.11
  - 定义
  - 声明并定义
  - 声明



### 2.2.3 标识符

- 2.12
  - `int double = 3.14;` 非法
  - `int _;` 合法
  - `int catch-22;` 非法
  - `int 1_or_2 = 1;` 合法
  - `double Double = 3.14` 合法



### 2.2.4 名字的作用域

- 2.13

  `j` 的值为 100



- 2.14

  程序合法，输出 `100 45`



## 2.3 复合类型

### 2.3.1 引用

- 2.15

  - 合法
  - 不合法，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起
  - 合法
  - 不合法，引用必须初始化



- 2.16

  - 合法，将 2 赋值给 `r2` 绑定的对象
  - 不合法，引用和其初始值对象一直绑定在一起，无法重新绑定到另一个对象
  - 合法，将 `r2` 绑定的对象赋值给 `i`
  - 合法，将 `d` 赋值给 `r1` 绑定的对象



- 2.17

  输出 `10 10`



### 2.3.2 指针

- 2.18

  ```c++
  int main(int argc, char const *argv[]) {
    int val1 = 102;
    int val2 = 300;
    int *p = &val1;
    *p = 2;     // 更改指针所指对象的值
    p = &val2;  // 更改指针的值
    return 0;
  }
  ```



- 2.19

  - 指针本身是一个对象，允许对指针进行赋值和拷贝，在指针的生命周期内，它可以指向不同的对象；而引用并非对象，它是已经存在的对象的别名，引用和其初始值对象一直绑定在一起，无法重新绑定到另一个对象；
  - 指针无须在定义时赋初值；而引用必须初始化。



- 2.20

  - 定义整型变量 `i`，并初始化其值为 42
  - 定义指针 `p1` 指向对象 `i`
  - 通过指针 `p1` 访问对象，实现平方运算，即 `42*42`



- 2.21

  - 非法，指针的类型与它所指对象的类型必须匹配
  - 非法，不能直接将 `int` 变量直接赋值给指针，即使 `int` 变量等于 0
  - 合法



- 2.22

  - 如果指针 `p` 的值不是 0，则
  - 如果指针 `p` 所指的对象不是 0，则



- 2.23

  无法判断。指针可能指向一个对象、指向紧邻对象所占空间的下一个地址、或任意对象。



- 2.24

  `void*` 指针可以存放任意类型对象的地址，因此 `p` 合法，而指针 `lp` 的类型与其所指对象不匹配，不合法。



### 2.3.3 理解复合类型的声明

- 2.25
  - `ip` 为 `int` 型指针；`i` 为 `int` 型变量；`r` 为对 `i` 的引用
  - `i` 为 `int` 型变量；`ip` 为 `int` 型空指针
  - `ip` 为 `int` 型指针；`ip2` 为 `int` 型变量



## 2.4 const 限定符

- 2.26
  - 不合法，`const` 对象没有初始化
  - 合法
  - 合法
  - 不合法，`const` 对象一旦创建后其值就不能再改变



### 2.4.2 指针和 const

- 2.27

  - 不合法，引用类型的初始值必须是一个对象
  - 合法， `p2` 是一个指向 `int` 型变量 `i2` 的 `const` 指针
  - 合法，`r` 是一个常量引用
  - 合法，`p3` 是一个指向常量对象的常量指针
  - 合法，`p1` 是一个指向常量对象的指针
  - 不合法
  - 合法，`i2` 是一个常量对象，`r` 是对常量的引用



- 2.28

  - 不合法，`const` 指针必须初始化
  - 不合法，`const` 指针必须初始化
  - 不合法，`const` 对象必须初始化
  - 不合法，`const` 指针必须初始化
  - 定义指向整型常量的指针 `p`



- 2.29

  - 合法
  - 合法
  - 合法
  - 不合法，`const` 指针的值一旦初始化完成，就不能改变
  - 不合法，同上
  - 不合法，`const` 对象一旦创建后其值就不能再改变



### 2.4.3 顶层 const

- 2.30

  `v2` 是顶层 `const`；`p2` 是底层 `const`；靠近 `p3` 的是顶层 `const`，较远的是底层 `const`；`r2` 是底层 `const`



- 2.31

  - `r1 = v2;` 合法，拷贝 `v2` 是可以忽略其顶层 `const`
  - `P1 = p2;` 不合法，`p2` 是底层 `const`，而 `p1` 没有
  - `P2 = p1;` 合法，`int*` 能转换成 `const int*`
  - `P1 = p3;` 不合法，`p3` 包含底层 `const`，而 `p1` 没有
  - `P2 = p3;` 合法，`p2` 和 `p3` 都是底层 `const`，拷贝 `p3` 时可以忽略其顶层 `const`



### 2.4.4 constexpr 和常量表达式

- 2.32

  不合法，修改为 `int null = 0, *p = &null;`



## 2.5 处理类型

### 2.5.2 auto 类型说明符

- 2.33

  - 整型变量 `a` 被赋值为 42
  - 整型变量 `b` 被赋值为 42
  - 整型变量 `c` 被赋值为 42
  - 整型指针 `d` 无法赋值，`int` 类型无法转换为 `int*` 类型
  - 指向整数常量的指针 `e` 无法赋值，`int` 类型无法转换为 `const int*` 类型
  - 整型常量 `g` 无法赋值，`const` 对象一旦创建后其值就不能再改变



- 2.34

  ```c++
  #include <iostream>
  
  int main(int argc, char const *argv[]) {
    int i = 0, &r = i;
    auto a = r;
    const int ci = i, &cr = ci;
    auto b = ci;
    auto c = cr;
    auto d = &i;
    auto e = &ci;
    auto &g = ci;
  
    std::cout << "Before: \na = " << a << "\nb = " << b << "\nc = " << c
              << "\nd = " << d << "\ne = " << e << "\ng = " << g << std::endl;
  
    a = 42;
    b = 42;
    c = 42;
    // d = 42;  // Error!
    // e = 42;  // Error!
    // g = 42;  // Error!
  
    std::cout << "After: \na = " << a << "\nb = " << b << "\nc = " << c
              << "\nd = " << d << "\ne = " << e << "\ng = " << g << std::endl;
    return 0;
  }
  ```



- 2.35

  `j` 为 `int` 类型；`k` 为的 `i` 常量引用；`p` 为 `int*` 类型；`j2` 为整形常量；`k2` 为的 `i` 常量引用

  ```c++
  #include <iostream>
  
  int main(int argc, char const *argv[]) {
    const int i = 42;
    auto j = i;
    const auto &k = i;
    auto *p = &i;
    const auto j2 = i, &k2 = i;
  
    std::cout << typeid(j).name() << std::endl;
    std::cout << typeid(k).name() << std::endl;
    std::cout << typeid(p).name() << std::endl;
    std::cout << typeid(j2).name() << std::endl;
    std::cout << typeid(k2).name() << std::endl;
    return 0;
  }
  ```



### 2.5.3 decltype 类型指示符

- 2.36

  `a` 整型；`b` 整型；`c` 整型；`d` `int&`

  `a = 4, b = 4, c = 4, d = 4`



- 2.37

  `a` 整型；`b` 整型；`c` 整型；`d` `int&`

  `a = 3, b = 4, c = 3, d = 3`



- 2.38

  auto 让编译器通过初试值推断变量的类型，并用初始值初始化变量；decltype 返回操作数的数据类型，可以不初始化变量。在处理引用时，前者一般忽略顶层 `const`，后者则返回包括顶层 `const` 和引用在内的变量类型。

  ```c++
  int ci = 0, &cj = ci;
  // 相同
  decltype(cj + 0) a;
  auto b = ci;
  // 不同
  decltype(cj) c = ci;
  auto d = ci;
  ```



## 2.6 自定义数据结构

### 2.6.1 定义 Sales_data 类型

- 2.39

  运行结果：`error: expected ';' after struct`



- 2.40

  ```c++
  struct Sales_data {
    std::string isbn;
    unsigned int num = 0;
    double price = 0.0;    // 单价
    double revenue = 0.0;  // 总收入
  };
  ```



### 2.6.2 使用 Sales_data 类

- 2.41

  - 1.20

    ```c++
    #include <iostream>
    
    struct Sales_data {
      std::string isbn;
      unsigned int num = 0;
      double price = 0.0;    // 单价
      double revenue = 0.0;  // 总收入
    };
    
    int main(int argc, char const *argv[]) {
      Sales_data data;
      while (std::cin >> data.isbn >> data.num >> data.price) {
        data.revenue = data.num * data.price;
        std::cout << data.isbn << " " << data.num << " " << data.revenue << " "
                  << data.price << std::endl;
      }
      return 0;
    }
    ```

  - 1.21

    ```c++
    #include <iostream>
    
    struct Sales_data {
      std::string isbn;
      unsigned int num = 0;
      double price = 0.0;    // 单价
      double revenue = 0.0;  // 总收入
    };
    
    int main(int argc, char const *argv[]) {
      Sales_data data1, data2;
      std::cin >> data1.isbn >> data1.num >> data1.price;
      std::cin >> data2.isbn >> data2.num >> data2.price;
      data1.revenue = data1.num * data1.price;
      data2.revenue = data2.num * data2.price;
    
      if (data1.isbn == data2.isbn) {
        unsigned int totalNum = data1.num + data2.num;
        double totalRevenue = data1.revenue + data2.revenue;
        double ave = totalRevenue / totalNum;
        std::cout << data1.isbn << " " << totalNum << " "
                  << data1.revenue + data2.revenue << " " << ave << std::endl;
      }
      return 0;
    }
    ```

  - 1.22

    ```c++
    #include <iostream>
    
    struct Sales_data {
      std::string isbn;
      unsigned int num = 0;
      double price = 0.0;    // 单价
      double revenue = 0.0;  // 总收入
    };
    
    int main(int argc, char const *argv[]) {
      Sales_data data, total;
      while (std::cin >> data.isbn >> data.num >> data.price) {
        data.revenue = data.num * data.price;
        total.isbn = data.isbn;
        total.num += data.num;
        total.revenue += data.revenue;
        total.price = total.revenue / total.num;
      }
      std::cout << "Total: " << total.num << " " << total.revenue << " "
                << total.price << std::endl;
      return 0;
    }
    ```

  - 1.23

    ```c++
    #include <iostream>
    
    struct Sales_data {
      std::string isbn;
      unsigned int num = 0;
      double price = 0.0;    // 单价
      double revenue = 0.0;  // 总收入
    };
    
    int main(int argc, char const *argv[]) {
      Sales_data currData, data;
      if (std::cin >> currData.isbn >> currData.num >> data.price) {
        int cnt = 1;
        while (std::cin >> data.isbn >> data.num >> data.price) {
          if (data.isbn == currData.isbn) {
            cnt++;
          } else {
            std::cout << "ISBN: " << currData.isbn << ", Num: " << cnt << std::endl;
            currData.isbn = data.isbn;
            currData.num = data.num;
            currData.price = data.price;
            cnt = 1;
          }
        }
        std::cout << "ISBN: " << currData.isbn << ", Num: " << cnt << std::endl;
      }
      return 0;
    }
    ```

  - 1.25

    ```c++
    #include <iostream>
    
    struct Sales_data {
      std::string isbn;
      unsigned int num = 0;
      double price = 0.0;    // 单价
      double revenue = 0.0;  // 总收入
    };
    
    int main(int argc, char const *argv[]) {
      Sales_data total;
      if (std::cin >> total.isbn >> total.num >> total.price) {
        total.revenue = total.num * total.price;
        Sales_data trans;
        while (std::cin >> trans.isbn >> trans.num >> trans.price) {
          trans.revenue = trans.num * trans.price;
          if (total.isbn == trans.isbn) {
            total.num += trans.num;
            total.revenue += trans.revenue;
          } else {
            total.price = total.revenue / total.num;
            std::cout << total.isbn << " " << total.num << " " << total.revenue
                      << " " << total.price << std::endl;
            total.isbn = trans.isbn;
            total.num = trans.num;
            total.price = trans.price;
            total.revenue = trans.revenue;
          }
        }
        total.price = total.revenue / total.num;
        std::cout << total.isbn << " " << total.num << " " << total.revenue << " "
                  << total.price << std::endl;
      } else {
        std::cerr << "No data?!" << std::endl;
        return -1;
      }
      return 0;
    }
    ```



### 2.6.3 编写自己的头文件

- 2.42

  ```c++
  #ifndef SALES_DATA_H
  #define SALES_DATA_H
  struct Sales_data {
    std::string isbn;
    unsigned int num = 0;
    double price = 0.0;    // 单价
    double revenue = 0.0;  // 总收入
  };
  #endif
  ```
