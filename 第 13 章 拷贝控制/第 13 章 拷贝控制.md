# 13.1 拷贝、赋值与销毁

## 13.1.1 拷贝构造函数

### 练习 13.1

> 拷贝构造函数是什么？什么时候使用它？

拷贝构造函数是一个第一个参数是自身类类型的引用，且任何额外参数都有默认值的构造函数。以下情况会使用拷贝构造函数：

- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员（参见 7.5.5 节，第 266 页）



### 练习 13.2

> 解释为什么下面的声明是非法的：
>
> ```c++
> Sales_data::Sales_data(Sales_data rhs);
> ```

拷贝构造函数的参数必须是引用类型，否则，调用永远不会成功——为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。



### 练习 13.3

> 当我们拷贝一个 StrBlob 时，会发生什么？拷贝一个 StrBlobPtr 呢？

- 拷贝 `StrBlob` 会将成员 `std::shared_ptr<std::vector<std::string>> data` 拷贝到正在创建的对象中，被拷贝对象的 `shared_ptr` 成员的引用计数会加 1

- 拷贝 `StrBlobPtr` 会将成员 `std::weak_ptr<std::vector<std::string>> wptr` 和 `std::size_t curr` 拷贝到正在创建的对象中，拷贝 `weak_ptr` 不会改变它所绑定的 `shared_ptr` 的引用计数（第 420 页）



### 练习 13.4

> 假定 Point 是一个类类型，它有一个 public 的拷贝构造函数，指出下面程序片段中哪些地方使用了拷贝构造函数：
>
> ```c++
> Point global;
> Point foo_bar(Point arg) {
>   Point local = arg, *heap = new Point(global);
>   *heap = local;
>   Point pa[4] = {local, *heap};
>   return *heap;
> }
> ```

- 函数 `foo_bar` 的参数
- 对象 `local` 使用拷贝初始化
- `new Point(global)` 显式调用拷贝构造函数
- 使用花括号列表初始化数组 `pa[4]`
- 函数 `foo_bar` 返回 `Point` 对象



### [练习 13.5](13.5.h)

> 给定下面的类框架，编写一个拷贝构造函数，拷贝所有成员。你的构造函数应该动态分配一个新的 string（参见 12.1.2 节，第 407 页），并将对象拷贝到 ps 所指向的位置，而不是拷贝 ps 本身：
>
> ```c++
> class HasPtr {
>  public:
>   HasPtr(const std::string& s = std::string()) : ps(new std::string(s)), i(0) {}
> 
>  private:
>   std::string* ps;
>   int i;
> }
> ```



## 13.1.2 拷贝赋值运算符

### 练习 13.6

> 拷贝赋值运算符是什么？什么时候使用它？合成拷贝赋值运算符完成什么工作？什么时候会生成合成拷贝赋值运算符？

拷贝赋值运算符是一个名为 `operator=` 的函数；进行赋值运算时使用拷贝赋值运算符；合成拷贝赋值运算符用来禁止某些类型对象的赋值，或者将右侧运算对象的每个非 `static` 成员赋予左侧运算对象的对应成员；如果类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符。



### 练习 13.7

> 当我们将一个 StrBlob 赋值给另一个 StrBlob 时，会发生什么？赋值 StrBlobPtr 呢？

- 将一个 `StrBlob` 赋值给另一个 `StrBlob` 时，会将赋值运算符右边对象的 `std::shared_ptr<std::vector<std::string>> data` 赋予左侧运算对象的对应成员，且递增右边对象 `shared_ptr` 成员的引用计数
- 将一个 `StrBlobPtr` 赋值给另一个 `StrBlobPtr` 时，会将赋值运算符右边对象的 `std::weak_ptr<std::vector<std::string>> wptr` 和 `std::size_t curr` 赋予左侧运算对象的对应成员



### [练习 13.8](13.8.h)

> 为 13.1.1 节（第 443 页）[练习 13.5](#练习-135) 中的 HasPtr 类编写赋值运算符。类似拷贝构造函数，你的赋值运算符应该将对象拷贝到 ps 指向的位置。



## 13.1.3 析构函数

### 练习 13.9

> 析构函数是什么？合成析构函数完成什么工作？什么时候会生成合成析构函数？

析构函数是类的一个成员函数，名字由波浪号接类名构成，它没有返回值，也不接受参数，析构函数执行与构造函数相反的操作，析构函数释放对象使用的资源，并销毁对象的非 `static` 数据成员；合成析构函数被用来阻止某些类的对象被销毁或者用来释放对象使用的资源，并销毁对象的非 `static` 数据成员；当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数。



### 练习 13.10

> 当一个 StrBlob 对象销毁时会发生什么？一个 StrBlobPtr 对象销毁时呢？

`StrBlob` 对象销毁时，析构函数释放对象使用的资源，并销毁对象的非 `static` 数据成员，即递减 `std::shared_ptr<std::vector<std::string>> data` 的引用计数器，若计数值为 0 则释放其所指向的内存空间；`StrBlobPtr` 对象销毁时，析构函数释放对象使用的资源，并销毁对象的非 `static` 数据成员 `curr`。



### [练习 13.11](13.11.h)

> 为前面练习中的 HasPtr 类添加一个析构函数。



### 练习 13.12

> 在下面的代码片段中会发生几次析构函数调用？
>
> ```c++
> bool fcn(const Sales_data *trans, Sales_data accum) {
>   Sales_data item1(*trans), item2(accum);
>   return item1.isbn() != item2.isbn();
> }
> ```

三次，参数 `accum` 以及局部变量 `item1` 和 `item2` 离开作用域时调用析构函数。



### [练习 13.13](13.13.cpp)

> 理解拷贝控制成员和构造函数的一个好方法是定义一个简单的类，为该类定义这些成员，每个成员都打印出自己的名字：
>
> ```c++
> struct X {
>   X() { std::cout << "X()" << std::endl; }
>   X(const X&) { std::cout << "X(const X&)" << std::endl; }
> };
> ```
>
> 给 X 添加拷贝赋值运算符和析构函数，并编写一个程序以不同的方式使用 X 的对象：将它们作为非引用和引用参数传递；动态分配它们；将它们存放于容器中；诸如此类。观察程序的输出，直到你确认理解了什么时候会使用拷贝控制成员，以及为什么会使用它们。当你观察程序输出时，记住编译器可以略过对拷贝构造函数的调用。



## 13.1.4 三/五法则

### 练习 13.14

> 假定 numbered 是一个类，它有一个默认构造函数，能为每个对象生成一个唯一的序号，保存在名为 mysn 的数据成员中。假定 numbered 使用合成的拷贝控制成员，并给定如下函数：
>
> ```c++
> void f(numbered s) { cout << s.mysn < endl; }
> ```
>
> 则下面代码输出什么内容
>
> ```c++
> numbered a, b = a, c = b;
> f(a);
> f(b);
> f(c);
> ```

输出三个相同的序号。



### 练习 13.15

> 假定 numbered 定义了一个拷贝构造函数，能生成一个新的序号。这会改变上一题中调用的输出结果吗？如果会改变，为什么？新的输出结果是什么？

会改变，函数 `f` 的实参被值传递（第 187 页），即调用拷贝构造函数将实参拷贝给形参。输出结果是三个不同的序号，且这三个序号与 `a`，`b` 和 `c` 的序号均不相同。



### 练习 13.16

> 如果 f 中的参数是 const numbered&，将会怎样？这会改变输出结果吗？如果会改变，为什么？新的输出结果是什么？

不会改变，函数 `f` 的实参被引用传递，不调用拷贝构造函数。输出结果是 `a`，`b` 和 `c` 的序号。



### 练习 13.17

> 分别编写前三题中所描述的 numbered 和 f，验证你是否正确预测了输出结果。

- [练习 13.14](13.14.cpp)
- [练习 13.15](13.15.cpp)
- [练习 13.16](13.16.cpp)



## 13.1.6 阻止拷贝

### [练习 13.18](13.18.h)

> 定义一个 Employee 类，它包含雇员的姓名和唯一的雇员证号。为这个类定义默认构造函数，以及接受一个表示雇员姓名的 string 的构造函数。每个构造函数应该通过递增一个 static 数据成员来生成一个唯一的证号。



### [练习 13.19](13.19.h)

> 你的 Employee 类需要定义它自己的拷贝控制成员吗？如果需要，为什么？如果不需要，为什么？实现你认为 Employee 需要的拷贝控制成员。

需要，因为雇员证号是唯一的，所以需要定义删除的函数来阻止拷贝。



### 练习 13.20

> 解释当我们拷贝、赋值或销毁 TextQuery 和 QueryResult 类（参见 12.3 节，第 430 页）对象时会发生什么？

- 拷贝 `TextQuery` 和 `QueryResult` 类对象会将成员拷贝到正在创建的对象中，被拷贝对象的 `shared_ptr` 成员的引用计数会加 1
- 赋值 `TextQuery` 和 `QueryResult` 类对象会依次将成员赋值，给 `shared_ptr` 成员进行赋值时会递减其原来指向的对象的引用计数，并递增新对象的引用计数
- 销毁 `TextQuery` 和 `QueryResult` 类对象会释放对象使用的资源，并销毁对象的非 `static` 数据成员，即递减 `shared_ptr` 的引用计数器，若计数值为 0 则释放其所指向的内存空间



### 练习 13.21

> 你认为 TextQuery 和 QueryResult 类需要定义它们自己版本的拷贝控制成员吗？如果需要，为什么？如果不需要，为什么？实现你认为这两个类需要的拷贝控制操作。

不需要，合成的拷贝控制成员的行为符合我们的预期。



# 13.2 拷贝控制和资源管理

### 练习 13.22

> 假定我们希望 HasPtr 的行为像一个值。即，对于对象所指向的 string 成员，每个对象都有一份自己的拷贝。我们将在下一节介绍拷贝控制成员的定义。但是，你已经学习了定义这些成员所需的所有知识。在继续学习下一节之前，为 HasPtr 编写拷贝构造函数和拷贝赋值运算符。



## 13.2.1 行为像值的类

### 练习 13.23

> 比较上一节练习中你编写的拷贝控制成员和这一节中的代码。确定你理解了你的代码和我们的代码之间的差异（如果有的话）。



### 练习 13.24

> 如果本节的 HasPtr 版本未定义析构函数，将会发生什么？如果未定义拷贝构造函数，将会发生什么？



### 练习 13.25

> 假定希望定义 StrBlob 的类值版本，而且希望继续使用 shared_ptr，这样我们的 StrBlobPtr 类就仍能使用指向 vector 的 weak_ptr 了。你修改后的类将需要一个拷贝构造函数和一个拷贝赋值运算符，但不需要析构函数。解释拷贝构造函数和拷贝赋值运算符必须要做什么。解释为什么不需要析构函数。



### 练习 13.26

> 对上一题中描述的 StrBlob 类，编写你自己的版本。



## 13.2.2 定义行为像指针的类

### 练习 13.27

> 定义你自己的使用引用计数版本的 HasPtr。



### 练习 13.28

> 给定下面的类，为其实现一个默认构造函数和必要的拷贝控制成员。
>
> (a)
>
> ```c++
> class TreeNode {
>  private:
>   std::string value;
>   int count;
>   TreeNode *left;
>   TreeNode *right;
> };
> ```
>
> (b)
>
> ```c++
> class BinStrTree {
>  private:
>   TreeNode *root;
> };
> ```



# 13.3 交换操作

### 练习 13.29

> 解释 swap(HasPtr&, HasPtr&) 中对 swap 的调用不会导致递归循环。



### 练习 13.30

> 为你的类值版本的 HasPtr 编写 swap 函数，并测试它。为你的 swap 函数添加一个打印语句，指出函数什么时候执行。



### 练习 13.31

> 为你的 HasPtr 类定义一个 < 运算符，并定义一个 HasPtr 的 vector。为这个 vector 添加一些元素，并对它执行 sort。注意何时会调用 swap。



### 练习 13.32

> 类指针的 HasPtr 版本会从 swap 函数受益吗？如果会，得到了什么益处？如果不是，为什么？
