# 13.1 拷贝、赋值与销毁

## 13.1.1 拷贝构造函数

### 练习 13.1

> 拷贝构造函数是什么？什么时候使用它？

拷贝构造函数是一个第一个参数是自身类类型的引用，且任何额外参数都有默认值的构造函数。以下情况会使用拷贝构造函数：

- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员（参见 7.5.5 节，第 266 页）



### 练习 13.2

> 解释为什么下面的声明是非法的：
>
> ```c++
> Sales_data::Sales_data(Sales_data rhs);
> ```

拷贝构造函数的参数必须是引用类型，否则，调用永远不会成功——为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。



### 练习 13.3

> 当我们拷贝一个 StrBlob 时，会发生什么？拷贝一个 StrBlobPtr 呢？

- 拷贝 `StrBlob` 会将成员 `std::shared_ptr<std::vector<std::string>> data` 拷贝到正在创建的对象中，被拷贝对象的 `shared_ptr` 成员的引用计数会加 1

- 拷贝 `StrBlobPtr` 会将成员 `std::weak_ptr<std::vector<std::string>> wptr` 和 `std::size_t curr` 拷贝到正在创建的对象中，拷贝 `weak_ptr` 不会改变它所绑定的 `shared_ptr` 的引用计数（第 420 页）



### 练习 13.4

> 假定 Point 是一个类类型，它有一个 public 的拷贝构造函数，指出下面程序片段中哪些地方使用了拷贝构造函数：
>
> ```c++
> Point global;
> Point foo_bar(Point arg) {
>   Point local = arg, *heap = new Point(global);
>   *heap = local;
>   Point pa[4] = {local, *heap};
>   return *heap;
> }
> ```

- 函数 `foo_bar` 的参数
- 对象 `local` 使用拷贝初始化
- `new Point(global)` 显式调用拷贝构造函数
- 使用花括号列表初始化数组 `pa[4]`
- 函数 `foo_bar` 返回 `Point` 对象



### [练习 13.5](13.5.h)

> 给定下面的类框架，编写一个拷贝构造函数，拷贝所有成员。你的构造函数应该动态分配一个新的 string（参见 12.1.2 节，第 407 页），并将对象拷贝到 ps 所指向的位置，而不是拷贝 ps 本身：
>
> ```c++
> class HasPtr {
>  public:
>   HasPtr(const std::string& s = std::string()) : ps(new std::string(s)), i(0) {}
> 
>  private:
>   std::string* ps;
>   int i;
> }
> ```



## 13.1.2 拷贝赋值运算符

### 练习 13.6

> 拷贝赋值运算符是什么？什么时候使用它？合成拷贝赋值运算符完成什么工作？什么时候会生成合成拷贝赋值运算符？

拷贝赋值运算符是一个名为 `operator=` 的函数；进行赋值运算时使用拷贝赋值运算符；合成拷贝赋值运算符用来禁止某些类型对象的赋值，或者将右侧运算对象的每个非 `static` 成员赋予左侧运算对象的对应成员；如果类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符。



### 练习 13.7

> 当我们将一个 StrBlob 赋值给另一个 StrBlob 时，会发生什么？赋值 StrBlobPtr 呢？

- 将一个 `StrBlob` 赋值给另一个 `StrBlob` 时，会将赋值运算符右边对象的 `std::shared_ptr<std::vector<std::string>> data` 赋予左侧运算对象的对应成员，且递增右边对象 `shared_ptr` 成员的引用计数
- 将一个 `StrBlobPtr` 赋值给另一个 `StrBlobPtr` 时，会将赋值运算符右边对象的 `std::weak_ptr<std::vector<std::string>> wptr` 和 `std::size_t curr` 赋予左侧运算对象的对应成员



### [练习 13.8](13.8.h)

> 为 13.1.1 节（第 443 页）[练习 13.5](#练习-135) 中的 HasPtr 类编写赋值运算符。类似拷贝构造函数，你的赋值运算符应该将对象拷贝到 ps 指向的位置。



## 13.1.3 析构函数

### 练习 13.9

> 析构函数是什么？合成析构函数完成什么工作？什么时候会生成合成析构函数？



### 练习 13.10

> 当一个 StrBlob 对象销毁时会发生什么？一个 StrBlobPtr 对象销毁时呢？



### [练习 13.11](13.11.h)

> 为前面练习中的 HasPtr 类添加一个析构函数。



### 练习 13.12

> 在下面的代码片段中会发生几次析构函数调用？
>
> ```c++
> bool fcn(const Sales_data *trans, Sales_data accum) {
>   Sales_data item1(*trans), item2(accum);
>   return item1.isbn() != item2.isbn();
> }
> ```



### 练习 13.13

> 理解拷贝控制成员和构造函数的一个好方法是定义一个简单的类，为该类定义这些成员，每个成员都打印出自己的名字：
>
> ```c++
> struct X {
>   X() { std::cout << "X()" << std::endl; }
>   X(const X&) { std::cout << "X(const X&)" << std::endl; }
> };
> ```
>
> 给 X 添加拷贝赋值运算符和析构函数，并编写一个程序以不同的方式使用 X 的对象：将它们作为非引用和引用参数传递；动态分配它们；将它们存放于容器中；诸如此类。观察程序的输出，直到你确认理解了什么时候会使用拷贝控制成员，以及为什么会使用它们。当你观察程序输出时，记住编译器可以略过对拷贝构造函数的调用。



## 13.1.4 三/五法则

### 练习 13.14

> 假定 numbered 是一个类，它有一个默认构造函数，能为每个对象生成一个唯一的序号，保存在名为 mysn 的数据成员中。假定 numbered 使用合成的拷贝控制成员，并给定如下函数：
>
> ```c++
> void f(numbered s) { cout << s.mysn < endl; }
> ```
>
> 则下面代码输出什么内容
>
> ```c++
> numbered a, b = a, c = b;
> f(a);
> f(b);
> f(c);
> ```



### 练习 13.15

> 假定 numbered 定义了一个拷贝构造函数，能生成一个新的序号。这会改变上一题中调用的输出结果吗？如果会改变，为什么？新的输出结果是什么？



### 练习 13.16

> 如果 f 中的参数是 const numbered&，将会怎样？这会改变输出结果吗？如果会改变，为什么？新的输出结果是什么？



### 练习 13.17

> 分别编写前三题中所描述的 numbered 和 f，验证你是否正确预测了输出结果。

